<html>
<head>
  <meta charset="UTF-8">
  <title>Component - canvas demo</title>
  <script src="../dist/component.min.js"></script>
  <!-- include an enhanced canvas 2dContext API add-on -->
  <script src="../dist/ctx.min.js"></script>
  <style>
    .container, video, .shadow-canvas {
      border: 1px solid #222;
      margin: 1em;
      width: 640px;
      height: 480px;
      user-select: none;
    }
    .tooltip {
      user-select: none;
     }
  </style>
</head>
<body>

  <canvas class="container"></canvas>
  <div class="tooltip"></div>

<script>
// Enable the enhanced canvas 2dContext API (optional).
// The extended `ctx` enables:
//  - HDPI aware size() method
//  - new drawing methods
//  - most methods are chainable
//  - save to image, record to video
Component.Ctx = Ctx;


// define a new component
const Foo = new Component({ frame: 0, x: 280, y: 100 });

// a reference to Foo.ctx, so we can access it outside the components view
let context,
    // objects used by our interactive canvas
    filledRect,
    myMickey,
    myStar,
    myStarFill,
    myStarStroke,
    myStarX = 200,
    myStarY = 400;

// define a "view", that draws to the components canvas
Foo.view = (props, ctx) => {
  const frame = props.frame;
  if (frame === 0) {
    // set the canvas size (w, h, aspectRatio)
    ctx.size(640, 480);
    // keep references for outside the Foo component
    context = ctx;
    // create interactive objects, using `ctx.create`
    filledRect = ctx.create.rect(30, 30, 200, 200);
    myStar = ctx.create.star(myStarX, myStarY, 50, 5, 0);
    // extend the ctx.create API with a new drawing function:
    // * all 3 circles will be seen as _one_ "canvas object"
    ctx.create('mickey', function(x, y, r) {
      [ctx, ctx.shadowCtx ].forEach(c => {
        c.beginPath();
        c.fillCircle(x,y,r/2, 360, true);         // head
        c.fillCircle(x-r/2,y-r/2,r/3, 360, true); // ear 1
        c.fillCircle(x+r/2,y-r/2,r/3, 360, true); // ear 2
        c.closePath();
      });
    });
    // now lets use it
    myMickey = ctx.create.mickey(100, 100, 80);
  }

  ctx.clear()  // using `clear(true)` will clear transforms too

  myMickey.onClick(props => console.log('mickey CLICK!'));
  myMickey.onHover(props => console.log('mickey HOVER!'));
  if (myMickey.drag) {
    myMickey.update(ctx.mouse.x, ctx.mouse.y, 80);
  }
  myMickey.draw({
    fillStyle: myMickey.hover ? '#c0c' : '#333',
  });


  filledRect.update(30+(frame/2), 30, 200, 200);

  filledRect.draw({
    fillStyle: filledRect.hover ? 'yellow' : 'lightblue',
    strokeStyle: filledRect.hover ? 'red' : 'blue',
    lineWidth: 3,
  });

  myStarFill = myStar.click ? 'lightgreen' : 'yellow';
  myStarStroke = myStar.hover ? 'red' : 'orange';

  if (myStar.drag) {
    myStarX = ctx.mouse.x;
    myStarY = ctx.mouse.y + myStar.props[2]/4;
    myStar.update(myStarX, myStarY, 50, 5, 0);
  }

  // or use event handlers  -  onHover, onClick, onDrag
  myStar.onHover(d => {
    console.log('myStar hover', d.shape);
  });
  myStar.onClick(d => {
    console.log('myStar clicked', d.id);
  });
  myStar.onRelease(d => {
    console.log('myStar released', d.id);
  });
  myStar.onDrag(d => {
    console.log('myStar dragging', d.props);
    // note that using `myStar.drag` (as above) works better
    //myStarX = ctx.mouse.x;
    //myStarY = ctx.mouse.y + d.props[2]/4;
    //myStar.update(myStarX, myStarY, 50, 5, 0);
  });

  myStar.draw({
    fillStyle: myStarFill,
    strokeStyle: myStarStroke,
    lineWidth: 5,
  });

  if (frame > 1000) return;

  // re-render in a loop
  Foo.setState({
    frame: frame + 1,
  });
};

// render to a canvas, and attach its context (`ctx`) to our component
Foo.render('.container', '2d');


// ..after the first frame renders (takes about 16 milliseconds)
// we can access `ctx` outside this components view, as `context`
setTimeout(() => {

  // update a toolip with object info on hover and click
  const tooltip = document.querySelector('.tooltip');

  context.canvas.addEventListener('mousemove', event => {
    // clear tooltip
    tooltip.innerHTML = ``;
    // if we are hovering on an object in the canvas
    if (context.hoverObj) {
      tooltip.innerHTML = `
        <br>  Mouse  x,y: ${event.offsetX}, ${event.offsetY}
        <br>   Object id: ${context.hoverObj.id}
        <br>Object props: ${context.hoverObj.props}
        <br>Object drag: ${context.hoverObj.drag}
      `;
    }
    //if (myStar && myStar.drag) {
    //  myStarX = context.mouse.x;
    //  myStarY = context.mouse.y + myStar.props[2]/4;
    //  myStar.update(myStarX, myStarY, 50, 5, 0);
    //}

  }, false);

  context.canvas.addEventListener('mousedown', event => {
    if (context.hoverObj) tooltip.innerHTML += `<br>Clicked`;
  }, false);

}, 20);



// move stuff around a bit in an animated loop
//const loop = setInterval(() => {
//  if (Foo.state.frame < 500) {
//    Foo.setState({
//      frame: Foo.state.frame + 1,
//    });
//  }
//}, 1000 / 30);

</script>
</body>
</html>

