<html>
<head>
  <meta charset="UTF-8">
  <title>Component - canvas demo</title>
  <script src="../dist/component.min.js"></script>
  <script src="../dist/chart.min.js"></script>
  <style>
    .container {
      border: 1px solid #222;
      margin: 1em;
      width: 640px;
      height: 480px;
    }
  </style>
</head>
<body>

  <canvas class="container"></canvas>

<script>


function smoothLines(points) {
  ctx.moveTo((points[0].x), points[0].y);
  for(var i = 0; i < points.length-1; i ++){
    const x_mid = (points[i].x + points[i+1].x) / 2;
    const y_mid = (points[i].y + points[i+1].y) / 2;
    const cp_x1 = (x_mid + points[i].x) / 2;
    const cp_x2 = (x_mid + points[i+1].x) / 2;
    ctx.quadraticCurveTo(cp_x1,points[i].y ,x_mid, y_mid);
    ctx.quadraticCurveTo(cp_x2,points[i+1].y ,points[i+1].x,points[i+1].y);
  }
}




// just testing stuff here...
const isType = (v,t) => typeof v === t;
const isFn = v => isType(v, 'function');
const isNum = v => isType(v, 'number');
const isArray = v => Array.isArray(v);
const fillArray = (num1, num2, steps = 1) => Array(Math.abs(num1-num2/steps)+1).fill(num1).map((v,i)=>v+(i*steps)*(num1>num2?-1:1));
const isDate = v => !!v.getDay;
const isDateValid = (...val) => !Number.isNaN(+new Date(...val));
const isDateRange  = r => isDate(r[0]) && isDate(r[1]);
const compareDates = (a, b) => a.getTime() > b.getTime();
const getDateRange = r => (new Date(r[0])-new Date(r[1]))/864e5|0;
const getDayDiff = (date1, date2) => Math.ceil(Math.abs(date1.getTime() - date2.getTime()) / 86400000);
// usage
const myRange = [ new Date('2021-01-01'), new Date('2021-01-31') ];
const dateRange = Math.abs(getDateRange(myRange));
//console.log('dateRange', dateRange);
//console.log('fillArray(0,100,5)', fillArray(0,100,5));
//console.log('......');


const getDayOfYear = (date) => Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24);
const getPastWeek = [...Array(7).keys()].map(days => new Date(Date.now() - 86400000 * days))
const getMonthDiff = (startDate, endDate) => Math.max(0, (endDate.getFullYear() - startDate.getFullYear()) * 12 - startDate.getMonth() + endDate.getMonth());
const getTimeFromDate = date => date.toTimeString().slice(0, 8);
const toYYYYMMDD = (date) => date.toISOString().slice(0, 10);

// Not tested/used yet:
// interpolate dates, from https://github.com/d3/d3-interpolate/blob/main/src/date.js
const interpolateDate = (a, b) => {
  const d = new Date;
  return a = +a,
         b = +b,
         (t) => d.setTime(a*(1-t)+b*t),
         d;
}

// interpolate string stuff.. use with fillArray()
const numbers = "1st Jan 2001".match(/[0-9]*/g);        //   returns ["1", "", "", "", "", "", "", "", "2001", ""]
const chars = "1st Jan 2001".match(/[A-Za-z ,\.]*/g)    //   returns ["", "st Jan ", "", "", "", "", ""]
numbers.map((n, i) => n.length>0 ? `${n}${chars[i+1]||''}` : ''); // returns ["1st Jan ", "", "", "", "", "", "", "", "2001", ""]

// also see https://gist.github.com/sc0ttj/619b832ac7bfdfc8b21a2b9b21eb3a5d

// DOM stuff
const isBrowserTabInView = () => document.hidden;
const elementIsInFocus = (el) => (el === document.activeElement);
const touchSupported = () => ('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch);
const goToTop = () => window.scrollTo(0, 0);


// array stuff

// remove all falsey values from an array
const compactArray = arr => arr.filter(a => a === 0 || !!a);
const accumulateValues = (arr) => arr.reduce((a, b, i) => (i === 0 ? [b] : [...a, b + a[i - 1]]), [0]); // in [1,2,3], out [1,3,6]
const countOccurrencesOfValue = (arr, val) => arr.reduce((a, v) => (v === val ? a + 1 : a), 0);
const findClosestValue = (arr, n) => arr.sort((a, b) => Math.abs(a - n) - Math.abs(b - n))[0];
const flatten = (arr) => arr.reduce((a, b) => (Array.isArray(b) ? [...a, ...flat(b)] : [...a, b]), []);
const indexOfMax = (arr) => arr.reduce((prev, curr, i, a) => (curr > a[prev] ? i : prev), 0);
const indexOfMin = (arr) => arr.reduce((prev, curr, i, a) => (curr < a[prev] ? i : prev), 0);
const isArrayEmpty = arr => Array.isArray(arr) && arr.length === 0;
// given two arrays, returns an array of the values which appear in both
const getIntersection = (arr1, ...arr2) => [...new Set(arr1)].filter((v) => arr2.every((b) => b.includes(v)));
const getMinValueOfKey = (arr, key) => arr.reduce((a, b) => (a[key] < b[key] ? a : b), {});
const getMaxValueOfKey = (arr, key) => arr.reduce((a, b) => (a[key] >= b[key] ? a : b), {});
const getSumOfArrayValues = (arr) => arr.reduce((a, b) => a + b, 0);
const removeDuplicatesFromArray = (arr) => [...new Set(arr)];
const sortDatesAscending = (arr) => arr.sort((a, b) => a.getTime() < b.getTime());
const sortDatesDescending = (arr) => arr.sort((a, b) => a.getTime() > b.getTime());
const shuffleArray = (arr) => arr.sort(() => 0.5 - Math.random());
// usage: toCartesianProduct([1, 2], [3, 4])  returns  [ [1, 3], [1, 4], [2, 3], [2, 4] ]
const toCartesianProduct = (...sets) => sets.reduce((acc, set) => acc.flatMap((x) => set.map((y) => [...x, y])), [[]]);
// swap the rows and columns of a matrix, example:
//    transposeMatrix([
//      [1, 2, 3], //  [1, 4, 7],
//      [4, 5, 6], //  [2, 5, 8],
//      [7, 8, 9], //  [3, 6, 9],
//    ]);
const transposeMatrix = (matrix) => matrix[0].map((col, i) => matrix.map((row) => row[i]));
// usage:  zipArray(['a', 'b', 'c'], [1, 2, 3]);   // returns [['a', 1], ['b', 2], ['c', 3]]
const zipArray = (...arr) => Array.from({ length: Math.max(...arr.map((a) => a.length)) }, (_, i) => arr.map((a) => a[i]));
// usage:  unzip([['a', 1], ['b', 2], ['c', 3]]);  //  returns [['a', 'b', 'c'], [1, 2, 3]]
const unzipArray = (arr) => arr.reduce((acc, c) => (c.forEach((v, i) => acc[i].push(v)), acc), Array.from({ length: Math.max(...arr.map((a) => a.length)) }, (_) => []));



// Array of object stuff:

const countByKey = (arr, prop) => arr.reduce((prev, curr) => ((prev[curr[prop]] = ++prev[curr[prop]] || 1), prev), {});
const pluckValuesByKey = (arr, prop) => arr.map((obj) => obj[prop]);



// Function stuff:

// Compose functions from left to right
// usage:  const funcs = pipe(fn1, fn2, fn3);  funcs();
const pipe = (...fns) => (x) => fns.reduce((y, f) => f(y), x);
// Sleep in async functions. Use: await sleep(2000).
const sleep = (ms) => (new Promise(resolve => setTimeout(resolve, ms)));


// Number stuff:

const celsiusToFahrenheit = (celsius) => celsius * 9/5 + 32;
const fahrenheitToCelsius = (fahrenheit) => (fahrenheit - 32) * 5/9;
const getAverage = (...nums) => nums.reduce((a, b) => a + b) / nums.length;
const isBetween = (min, max, number) => (min <= number && number <= max);
// pad anumber with leading zeros
const pad = (num) => ('0' + num).split('').reverse().splice(0,2).reverse().join('')
// round  anumber to given decimal places
const roundNum = (n, d) => Number(Math.round(n + "e" + d) + "e-" + d); // round(1.005, 2)   // 1.01
// truncate a number to given decimal places
const toFixed = (n, fixed) => ~~(Math.pow(10, fixed) * n) / Math.pow(10, fixed); // toFixed(25.198726354, 3);   // 25.198

// Object stuff

// remove all props with falsey values from the given object
const compactObject = (obj) => Object.keys(obj).reduce((acc, a) => Object.assign(acc, !!obj[a] ? {[a]: obj[a]} : {}), {});
// invert { a: 1, b: 2 } to { 1: a, 2: b }
const invertObjectKeysToValues = (obj) => Object.keys(obj).reduce((res, k) => Object.assign(res, { [obj[k]]: k }), {});
const invertObject = invertObjectKeysToValues;


// String stuff:

const reverseString = str => [...str].reverse().join``;
const stripHtmlFromString = str => (new DOMParser().parseFromString(html, 'text/html')).body.textContent || ''
// truncate a string to if over max length, and add elipses (...)
const truncateString = (str, maxLength) => str.length > maxLength ? `${str.substr(0, maxLength - 1)}â€¦` : str



// Sorting stuff

// To sort numbers
// in ascending order (1, 2, 3...): function(a, b){return a - b;}
// in descending order (9, 8, 7...): function(a, b){return b - a;}

// To sort strings
// in ascending order (A, B, C...): function(a, b){return a > b? 1: -1;}
// in descending order (Z, Y, X...): function(a, b){return b > a? 1: -1;}

// To sort objects add them to an array,
// then sort by key: function(a, b){return a.key - b.key;}

// =============================================================================



  let frame = 1; // frame count
  const colors = [
    '#FF4136',
    '#0074D9',
    '#B10DC9',
    '#2ECC40',
    '#FF851B',
    '#F012BE',
    '#FFDC00',
    '#39CCCC',
    '#85144b',
    '#01FF70',
    'yellow', 'red', 'green', 'blue', 'orange', '#666', '#333', 'magenta', 'grey', 'cyan' ];

  // Enable our Chart addon, it'll create an extended 2dContext,
  // with a chainable API, and these extra methods:
  //
  //    .data(), .margin(), .xAxis(), .yAxis(), .each(),
  //
  // Inside `.each()`, you get these drawing methods:
  //
  //    data.circle(), data.bar(), data.line(), data.pie()
  //
  Component.Ctx = Chart;

  // define a new component
  const myChart = new Component({ sizeX: 640, sizeY: 520 });

  // define the "view", that draws to the components canvas
  myChart.view = (props, ctx) => {

    if (frame === 1) {
      // set the canvas size (w, h, aspectRatio)
      ctx.size(props.sizeX, props.sizeY)  // set width and height, ignore aspect ratio
      //ctx.size(640, 480, null)   // same as above
      //ctx.size(null, 480, 4/3)   // set as 4:3,  grow till height = 4.0
      //ctx.size(null, 480, 16/9)  // set as 16:9, grow till height = 480
      //ctx.size(640, null, 3/4)   // set as 4:3, crop till width = 640
      //ctx.size(640, null, 9/16)  // set as 16:9, crop till width = 640
      //console.clear();
      frame++;
      return;
    }

    ctx.clear()

    .translate(0.5,0.5) // crisp lines trick


    // Pass in your data, an array of objects for simple bar charts, or
    // (more useful for grouped bar charts & line charts) an object of arrays:
    .useData({
      'USA':
      [
        { year: 2000, medals: 7, open: 3, close: 5, low: 2, high: 6 },
        { year: 2001, medals: 9, open: 5, close: 6, low: 2, high: 6 },
        { year: 2002, medals: 5, open: 6, close: 3, low: 2, high: 4 },
        { year: 2003, medals: 12, open: 3, close: 4, low: 1, high: 8 },
        { year: 2004, medals: 4, open: 4, close: 3, low: 1, high: 5 },
        { year: 2005, medals: 10, open: 3, close: 5, low: 2, high: 6 },
        { year: 2006, medals: 8, open: 5, close: 6, low: 2, high: 6 },
      ],
      'UK':
      [
        { year: 2000, medals: 4, open: 3, close: 5, low: 2, high: 6 },
        { year: 2001, medals: 12, open: 5, close: 6, low: 2, high: 6 },
        { year: 2002, medals: 14, open: 6, close: 3, low: 2, high: 4 },
        { year: 2003, medals: 8, open: 3, close: 4, low: 1, high: 8 },
        { year: 2004, medals: 6, open: 4, close: 3, low: 1, high: 5 },
        { year: 2005, medals: 5, open: 3, close: 5, low: 2, high: 6 },
        { year: 2006, medals: 9, open: 5, close: 6, low: 2, high: 6 },
      ],
    })

    .margin(40,80,170,80)  // top, bottom, left, right

    .setStyle({
      font: 'Normal 0.875rem Sans-Serif',
    })

    .xAxis({
      range: [1999,2007],
      scale: 1,
      label: "Years",
      labelBelow: true,
      yPos: 0,
      tickLength: -3,
      tickCentered: true,
      tickLabelCentered: true,
      tickLabels: (label, i) => (i === 0 || i === 8) ? '' : label,
      style: {
        lineWidth: 5,
        strokeStyle: 'red',
      }
    })

    .yAxis({
      range: [0,15],
      scale: 1,
      label: `Gold medals`,
      labelLeft: true,
      xPos: 0,
      tickLength: -3,
      tickCentered: true,
      tickLabels: [],
    })

    .drawEach( (country, name, i) => {
      // Now we can work with some "decorated" chart data, ${data}.
      // You might wanna use your top-level ${data} here - e.g. to draw a legend

      // Also available, just FYI:
      //const { x, y, h, w, margin, xRange, yRange, xScale, yScale, xDistance, yDistance } = ctx.dimensions();
      // Do whatever you like with these params, if anything..
      //    x/y         = the x/y origins of the chart area, accounting for margins
      //    w/h         = the x/y end points of the chart area, accounting for margins
      //    margin      = the space in px outside the chart area, in format { top, bottom, left, right }
      //    x/yRange    = the min/max data values of the x/y axes
      //    x/yScale    = the number by which axis values are multiplied
      //    x/yDistance = the tick distance (in px) along the x and y axes

      // Now lets go over each bit of "decorated" data for this country
      country.forEach((data, n) => {
        // You should only define the attrs you want "joined" to your
        // data - and don't override any others!
        //data.bar({
        //  height: data.medals,
        //  stacked: false,
        //  style:{ fill: colors[i] },
        //});
        //data.circle({
        //  cy:     data.medals,
        //  radius: data.medals*2,
        //  start: 0,
        //  end: 360,
        //  rotate: 0,
        //  style: { fill: colors[i+2], lineWidth: 5, stroke: 'red' },
        //});
        data.pie({
          px: 0,
          py: 0,
          slice: data.medals,
          radius: 100,
          //innerRadius: 120,
          style: { fill: colors[n] },
        });
        //data.arc({
       //   slice: data.medals,
       //   radius: 80,
       //   innerRadius: 40,
       //   style: { fill: colors[n] },
        //});
        //data.line({
        //  py: data.medals,
        //  stacked: true,
        //  smooth: true,
        //  style: {
        //    fill: colors[i],
        //    stroke: colors[i],
        //    lineWidth: 2,
        //  },
        //});
        //data.candle({
        //  open: data.open,
        //  close: data.close,
        //  high: data.high,
        //  low: data.low,
        //  style: {
        //    lineWidth: 1,
        //  }
        //})
      });
    })





    frame++;
  };


  // render to a canvas, and attach its context (`ctx`) to our component
  myChart.render('.container', '2d');

</script>
</body>
</html>
