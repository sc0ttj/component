<html>
<head>
  <meta charset="UTF-8">
  <title>Component - canvas demo</title>
  <script src="../dist/component.min.js"></script>
  <script src="../dist/chart.min.js"></script>
  <style>
    .container {
      border: 1px solid #222;
      margin: 1em;
      width: 640px;
      height: 480px;
    }
  </style>
</head>
<body>

  <canvas class="container"></canvas>

<script>



const isFn = v => typeof v ==='function';
const isArray = v => Array.isArray(v);
const isDate = v => isFn(v.getDay);
const isDateRange  = r => isDate(r[0]) && isDate(r[1]);
const getDateRange = r => (new Date(r[0])-new Date(r[1]))/864e5|0;
const fillRange = (num1, num2, steps = 1) => Array(Math.abs(num1-num2/steps)+1).fill(num1).map((v,i)=>v+(i*steps)*(num1>num2?-1:1));
// example usage
const myRange = [ new Date('2021-01-01'), new Date('2021-01-31') ];
const dateRange = Math.abs(getDateRange(myRange));
//console.log('dateRange', dateRange);
//console.log('fillRange(0,100)', fillRange(0,100,5));
//console.log('......');

// Not tested/used yet:

// interpolate dates, from https://github.com/d3/d3-interpolate/blob/main/src/date.js
const interpolateDate = (a, b) => {
  const d = new Date;
  return a = +a,
         b = +b,
         (t) => d.setTime(a*(1-t)+b*t),
         d;
}

// interpolate string stuff.. use with fillRange()
const numbers = "1st Jan 2001".match(/[0-9]*/g);        //   returns ["1", "", "", "", "", "", "", "", "2001", ""]
const chars = "1st Jan 2001".match(/[A-Za-z ,\.]*/g)    //   returns ["", "st Jan ", "", "", "", "", ""]
numbers.map((n, i) => n.length>0 ? `${n}${chars[i+1]||''}` : ''); // returns ["1st Jan ", "", "", "", "", "", "", "", "2001", ""]



// Data stuff:
//
// Functions for working with Objects:
//
// Given the object `{ name: "Bob" }`, returns an object like  `{ key: "name", value: "Bob" }`
const objToKeyValuePairs = obj => Object.keys(obj).map((key) => ({ key, value: obj[key] }));
//
//
// Functions for working with Arrays of Objects:
//
// Converts array of object in array of objects containing key/value pairs
const toKeyValuePairs = array => array.map(obj => objToKeyValuePairs(obj));
// Given an array of objects, returns an object "keyed" by the given `prop` value
const toKeyedObject = (array, key, obj = {}) => { array.forEach(item => obj[item[key]] = item); return obj; };
// Sort an array of objects by the given object `prop` - returns an array,
// - if asc=true,  the object with the _lowest_ `prop` value comes first
// - if asc=false, the object with the _highest_ `prop` value comes first
const sortByKey = (array, prop, order = 'asc') => [...array].sort((a, b) => order === 'asc' ? a[prop]-b[prop] : b[prop]-a[prop]);
const sortByKeyAsc = (array, prop) => sortByKey(array, prop, 'asc');
const sortByKeyDesc = (array, prop) => sortByKey(array, prop, 'desc');
// Get the combined total value of the given object property, in an array of objects,
// note that each object in the array must contain the given property (`prop`)
const getSumTotal = (array, prop) => array.reduce((prev, cur) => prev + cur[prop], 0);
// Get the min/max value of the given `prop` from objects in the given `array` of objects
const getMinOrMaxValue = (array, prop, which) => Math[which](...array.map(obj => obj[prop]));
// Get the min value of the given `prop` from objects in the given `array` of objects
const getMinValue = (array, prop) => getMinOrMaxValue(array, prop, 'min');
// Get the max value of the given `prop` from objects in the given `array` of objects
const getMaxValue = (array, prop) => getMinOrMaxValue(array, prop, 'max');
// Get the object from `array` that has the lowest or highest value for `prop`
const getObjectWithMinOrMaxValue = (array, prop, which) => array.reduce((max, obj) => which === 'min' ? max[prop]<obj[prop]?max:obj : max[prop]>obj[prop]?max:obj);
// Get the object from `array` that has the lowest value for `prop`
const getObjectWithMinValue = (array, prop) => getObjectWithMinOrMaxValue(array, prop, 'min');
// Get the object from `array` that has the highest value for `prop`
const getObjectWithMaxValue = (array, prop) => getObjectWithMinOrMaxValue(array, prop, 'max');


// =============================================================================



  let frame = 1; // frame count
  const colors = [ 'red', 'lightblue', 'lightgreen', 'orange', 'pink', 'limegreen', 'magenta', 'grey', 'cyan' ];

  // Enable our Chart addon, it'll create an extended 2dContext,
  // with a chainable API, and these extra methods:
  //
  //    .data(), .margin(), .xAxis(), .yAxis(), .each(),
  //
  // Inside `.each()`, you get these drawing methods:
  //
  //    data.circle(), data.bar(), data.line(), data.pie()
  //
  Component.Ctx = Chart;

  // define a new component
  const myChart = new Component({ sizeX: 640, sizeY: 520 });

  // define the "view", that draws to the components canvas
  myChart.view = (props, ctx) => {

    if (frame === 1) {
      // set the canvas size (w, h, aspectRatio)
      ctx.size(props.sizeX, props.sizeY)  // set width and height, ignore aspect ratio
      //ctx.size(640, 480, null)   // same as above
      //ctx.size(null, 480, 4/3)   // set as 4:3,  grow till height = 4.0
      //ctx.size(null, 480, 16/9)  // set as 16:9, grow till height = 480
      //ctx.size(640, null, 3/4)   // set as 4:3, crop till width = 640
      //ctx.size(640, null, 9/16)  // set as 16:9, crop till width = 640
      //console.clear();
      frame++;
      return;
    }

    ctx.clear()


    // Pass in your data, an array of objects for simple bar charts, or
    // (more useful for grouped bar charts & line charts) an object of arrays:
    .data({
      'USA':
      [ {},
        { medals: 19 },
        { medals: 30 },
        { medals: 23 },
        { medals: 25 },
        { medals: 12 },
        { medals: 16 },
        { medals: 23 },
      ],
      'UK':
      [ {},
        { medals: 10 },
        { medals: 9  },
        { medals: 18 },
        { medals: 18 },
        { medals: 15 },
        { medals: 21 },
        { medals: 24 },
      ]
    })

    .margin(40,80,130,80)  // top, bottom, left, right

    .xAxis([1999,2007],  1, 0, -4, "Years", true, true, []) // range, scale, yPos(%), tickSize(%), name, nameBelow, tickLabelsCentered, tickLabels
    .yAxis([0,     50],  5, 0, -2, "Gold Medals", true, []) // range, scale, xPos(%), tickSize(%), name, namelLeft, tickLabels

    .drawEach((country, name, i) => {
      // Now we can work with some "decorated" chart data, ${data}.
      // You might wanna use your top-level ${data} here - e.g. to draw a legend

      // Also available, just FYI:
      //const { x, y, h, w, margin, xRange, yRange, xScale, yScale, xDistance, yDistance } = ctx.dimensions();
      // Do whatever you like with these params, if anything..
      //    x/y         = the x/y origins of the chart area, accounting for margins
      //    w/h         = the x/y end points of the chart area, accounting for margins
      //    margin      = the space in px outside the chart area, in format { top, bottom, left, right }
      //    x/yRange    = the min/max data values of the x/y axes
      //    x/yScale    = the number by which axis values are multiplied
      //    x/yDistance = the tick distance (in px) along the x and y axes

      // Now lets go over each bit of "decorated" data for this country
      country.forEach((data, n) => {
        // You should only define the attrs you want "joined" to your
        // data - and don't override any others!
        data.bar({
          height: data.medals,
          fill: colors[i],
        });
        data.circle({
          cy:     data.medals,
          radius: data.medals/2,
          fill:   colors[i],
          start: 0,
          end: 360,
          rotate: 0,
        });
        data.line({
          py:        data.medals,
          stroke:    colors[i],
          lineWidth: 3,
        });
      });
    })

    // ..or change data and add a pie chart
    .data([
      { medals: 5 },
      { medals: 30 },
      { medals: 10 },
      { medals: 100 },
    ])
    .drawEach(item => {
      item.forEach((data, i) => {
        data.pie({
          slice:  data.medals, // turns into a % of 360 degrees
          fill: colors[i],
          px: 420,
          py: 100,
          radius: 60,
        });
      });
    })




    frame++;
  };


  // render to a canvas, and attach its context (`ctx`) to our component
  myChart.render('.container', '2d');

</script>
</body>
</html>
