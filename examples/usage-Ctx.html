<html>
<head>
  <meta charset="UTF-8">
  <title>Component - canvas demo</title>
  <script src="../dist/component.min.js"></script>
  <!-- include an enhanced canvas 2dContext API add-on -->
  <script src="../dist/ctx.min.js"></script>
  <style>
    .container, video {
      border: 1px solid #222;
      margin: 1em;
    }
  </style>
</head>
<body>

  <canvas class="container"></canvas>

  <video controls></video>

<script>

  // Enable the enhanced canvas 2dContext API (optional).
  // The extended `ctx` enables:
  //  - HDPI aware size() method
  //  - new drawing methods
  //  - most methods are chainable
  //  - save to image, record to video
  Component.Ctx = Ctx;


  // define a new component
  const Foo = new Component({ x: 280, y: 100 });

  // will be a reference to Foo.ctx, so we can access it outside the components view
  let context;


  // define a "view", that draws to the components canvas
  Foo.view = (props, ctx) => {

    context = ctx;

    ctx
      .clear()  // using `clear(true)` will clear transforms too
      .size(640, 480)

      .drawSvg(`<svg xmlns="http://www.w3.org/2000/svg" stroke="#000" stroke-width="2">
       <rect x="80" y="60" width="150" height="150" rx="20" fill="#F00"/>
       <rect x="100" y="80" width="150" height="150" rx="40" fill="#00F" fill-opacity=".7"/>
      </svg>`, 100, 200, 250, 200) // urlOrCode, x, y, w, h

      .beginPath()
      .moveTo(0, 0)
      .strokeStyle('blue')
      .lineTo(props.x, props.y)
      .stroke()

      .beginPath()
      .strokeStyle('black')
      .rect(props.x / 2, props.y / 2, 50, 50)
      .stroke()

      .beginPath()
      .fillStyle('yellow')
      .strokeStyle('green')
      .fillRoundedRect(10, 70, 50, 75, 10)
      .stroke()

      .beginPath()
      .fillStyle('red')
      .fillRect((props.x / 2) + 6, (props.y / 2) + 6, 38, 38)

      .beginPath()
      .strokeStyle('pink')
      .lineWidth(4)
      .strokeTriangle(220, 60, 50, 45)

      .beginPath()
      .fillStyle('green')
      .fillRing(80, 100, (props.y / 8) + 10, (props.y / 8) + 20, 100)

      .beginPath()
      .strokeStyle('yellow')
      .strokeStar(200, 200, 50, 5, 0)

  };

  // render to a canvas, and attach its context (`ctx`) to our component
  Foo.render('.container', '2d');


  // ..after the first frame renders (takes about 16 milliseconds)
  // we can access `ctx` outside this components view, as `context`
  setTimeout(() => {
    context.video.record(24); // start recording a video @24fps
  }, 20);


  // move stuff around a bit in an animated loop
  const loop = setInterval(() => {

    Foo.setState({
      x: 300,
      y: Foo.state.y += 1
    });

  }, 1000 / 60);


  // after 3 seconds, stop loop, stop recording the canvas to video,
  // and offer to download it
  setTimeout(() => {
    clearInterval(loop);
    context.video.stop();
    context.video.toElement(el => document.querySelector('video').src = el.src);
    context.video.saveAs('canvas-as-video.webm');
  }, 3000);

</script>
</body>
</html>
