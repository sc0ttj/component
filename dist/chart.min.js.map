{"version":3,"file":"chart.min.js","sources":["../src/chart.js"],"sourcesContent":["/*\n * Based on Canvas Context2D Wrapper <http://github.com/millermedeiros/CanvasContext2DWrapper>\n *\n */\n\n// @TODO Fixes and improvements:\n//\n// - new: style and tickStyle params for axes ?\n//\n// - demo: radial bar chart            - just a bunch of arc charts, wrapped round like russian dolls (https://nivo.rocks/radial-bar/)\n// - demo: heatmap charts              - series of stacked bars, all stacked bits same size, covers whole area w, coloured by data\n// - demo: parallel charts             - like this one: https://datavizcatalogue.com/methods/parallel_coordinates.html\n\nconst ctxMethods = 'arc arcTo beginPath bezierCurveTo clearRect clip closePath createImageData createLinearGradient createRadialGradient createPattern drawFocusRing drawImage fill fillRect fillText getImageData isPointInPath lineTo measureText moveTo putImageData quadraticCurveTo rect restore rotate save scale setTransform stroke strokeRect strokeText transform translate'.split(' ');\nconst ctxProps = 'canvas fillStyle font globalAlpha globalCompositeOperation lineCap lineJoin lineWidth miterLimit shadowOffsetX shadowOffsetY shadowBlur shadowColor strokeStyle textAlign textBaseline'.split(' ');\n\n/**\n* Wrap function to enable method chaining.\n* @param {Function} fn\tFunction to be modified.\n* @param {Object} scope\tScope where function will be called.\n* @param {Object} chainReturn\tObject returned to enable chaining.\n* @return {Function} Chainable function.\n* @private\n*/\nfunction chainMethod(fn, scope, chainReturn) {\n  return function() {\n    \treturn fn.apply(scope, arguments) || chainReturn;\n  };\n}\n\n/**\n* Convert properties into getter/setter methods enabling chaining.\n* @param {String} propName\tProperty name.\n* @param {Object} scope\tObject that contain original property.\n* @param {Object} chainReturn\tObject returned to enable chaining.\n* @return {Function} Chainable getter/setter for properties.\n* @private\n*/\nfunction chainProperty(propName, scope, chainReturn) {\n  return function(value) {\n  \tif(typeof value === 'undefined') {\n  \t\treturn scope[propName];\n  \t}else{\n  \t\tscope[propName] = value;\n  \t\treturn chainReturn;\n  \t}\n  };\n}\n\nconst PIXEL_RATIO = (function () {\n  return typeof window !== 'undefined'\n    ? (window && window.devicePixelRatio) || 1\n    : 1;\n})();\n\n\n// helper funcs\nconst isFn = v => typeof v ==='function',\n      isArray = v => Array.isArray(v),\n      isAxisFlipped = range => isArray(range) ? range[0] > range[1] : false,\n      axisMin  = range => isArray(range) ? isAxisFlipped(range)?range[1]:range[0] : 0,\n      getRange = range => isArray(range) ? isAxisFlipped(range)?range[0]-range[1]:range[1]-range[0]: 0,\n      deg2rad = deg => +deg*Math.PI/180,\n      getSumTotal = (array, prop) => array.filter(item => item[prop]).reduce((prev, cur) => prev + cur[prop], 0);\n\n\n// returns the scaled value of the given position in the given range\n//const scale = ({ range, scale, position }) => {\n//  const [min, max] = range;\n//  return min + (position - min) * scale;\n//};\n\nconst setStyle = (ctx, obj) => {\n  let fixedProp;\n  for(let prop in obj) {\n    fixedProp = prop;\n    if (prop === 'fill') fixedProp = 'fillStyle';\n    if (prop === 'stroke') fixedProp = 'strokeStyle';\n    ctx[fixedProp] = obj[prop];\n  };\n};\n\n// returns the dimensions and sizings used by the chart/graph\nfunction getDimensions(ctx) {\n  const c = ctx.canvas,\n        m = ctx.margin,\n        w = c.width - m.right - m.left,\n        h = c.height - m.top - m.bottom,\n        x = m.left,\n        y = m.top + h;\n  const { xRange, yRange, xScale, yScale, xLabels, yLabels, xDistance, yDistance } = ctx._d;\n  return { x, y, w, h, margin: m, xRange, yRange, xScale, yScale, xLabels, yLabels, xDistance, yDistance };\n}\n\n// draws the main line of the axis, used by xAxis and yAxis\nfunction drawAxisLine(ctx, dimensions, whichAxis = 'x', pos, style = {}) {\n  const { w, h, x, y } = dimensions;\n  ctx.save();\n  if (!style.strokeStyle && !style.stroke) style.stroke = '#222';\n  if (style) setStyle(ctx, style);\n  ctx.beginPath();\n  if (whichAxis === 'x') {\n    let py = y-(h/100*pos);\n    ctx.moveTo(x,py)\n    ctx.lineTo(x+w,py)\n  } else {\n    let px = x+(w/100*pos);\n    ctx.moveTo(px,y)\n    ctx.lineTo(px,y-h)\n  }\n  ctx.closePath();\n  ctx.stroke();\n  ctx.restore();\n}\n\n// draws the ticks along the axis, used by xAxis and yAxis\nfunction drawAxisTicks(ctx, dimensions, whichAxis = 'x', pos, tickLength, tickCentered, distanceBetweenTicks, scale, tickStyle = {}) {\n  const { w, h, x, y } = dimensions,\n        max = (whichAxis === 'x') ? w : h,\n        centered = tickCentered ? 0 : distanceBetweenTicks/2;\n\n  if (tickLength !== 0) {\n    ctx.save();\n    if (!tickStyle.strokeStyle && !tickStyle.stroke) tickStyle.stroke = '#bbb';\n    if (tickStyle) setStyle(ctx, tickStyle);\n    for (let i=0, p=0; i<=max+(tickCentered ? distanceBetweenTicks/4 : 0); i+=Math.round(distanceBetweenTicks)*scale){\n      ctx.beginPath();\n      if (whichAxis === 'x' && x+i+centered <= x+w) {\n        const px = x+i+centered,\n              py = pos < 50 ? y : y-h;\n        ctx.moveTo(px,py);\n        ctx.lineTo(px,py-(tickLength/100*h))\n      }\n      if (whichAxis === 'y' && y-i-centered >= y-h) {\n        const px = pos < 50 ? x : x+w,\n              py = y-i-centered;\n        ctx.moveTo(px,py);\n        ctx.lineTo(px+(tickLength/100*w),py);\n      }\n      ctx.stroke();\n      ctx.closePath();\n    }\n    ctx.restore();\n  }\n}\n\n// returns either a default tick label, generated from the given range, or\n// taken `labels` if an array, or the default is passed in `labels` if it's\n// a function, and whatever is returned is used\nconst getTickLabel = (range, flippedAxis, pos, scale, labels) => {\n  const abs = Math.abs,\n        autoLabel = flippedAxis\n          ? range[1]+abs(pos*scale)\n          : range[0]+abs(pos*scale);\n\n  let tickLabel = (Array.isArray(labels) && typeof labels[pos]!=='undefined')\n    ? labels[pos]\n    : autoLabel;\n\n  if (isFn(labels)) {\n    tickLabel = labels(autoLabel, pos)\n  }\n\n  return tickLabel;\n}\n\nconst getTextWidth  = (ctx, t) => ctx.measureText(t).width;\n\nconst getTextHeight = (ctx, t) => {\n  const metrics = ctx.measureText(t);\n  return metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent;\n}\n\n\n// Now define the extra methods to add/bind to our extended 2d canvas context\nconst extraMethods = {\n\n  // general helper funcs\n  clear: function(resetTransform) {\n    if (resetTransform === true) this.setTransform(1, 0, 0, 1, 0, 0);\n    this.clearRect(0, 0, this.canvas.width * PIXEL_RATIO, this.canvas.height * PIXEL_RATIO);\n  },\n  size: function(w, h, a) {\n    if (this.w === w && this.h === h) return; // if no new size, just return\n    // if width or height not given, get them from aspect ratio\n    this.w = w ? w : h * a;\n    this.h = h ? h : w * a;\n    // respect device pixel ratio\n    const c = this.canvas,\n          s = c.style;\n    c.width = this.w * PIXEL_RATIO;\n    c.height = this.h * PIXEL_RATIO;\n    // update the CSS too\n    s.width = this.w + 'px';\n    s.height = this.h + 'px';\n    s.objectFit = a ? 'contain' : null;\n    // adjust scale for pixel ratio\n    if (this.contextType === '2d' && PIXEL_RATIO !== 1) {\n      this.scale(PIXEL_RATIO, PIXEL_RATIO);\n    }\n  },\n\n  dimensions: function() {\n    return getDimensions(this);\n  },\n\n  useData: function(data) {\n    this.prevData = this.d;\n    // If `data` if a func, run it, passing in the previous data (which\n    // might be useful), else, just set the given data.\n    this.d = isFn(data) ? data(this.prevData) : data;\n    // internal chart data, used to calculate positions, sizes, etc\n    this._d = this._d || {};\n  },\n\n\n  // This function is super important - it maps over the data give in data(),\n  // then \"decorates\" it, so it's easier to draw that data to the chart area.\n  //\n  drawEach: function(fn) {\n    if (!this.d) return;\n\n    const { w, h, x, y } = getDimensions(this),\n        _d = this._d,\n        minXRange = axisMin(_d.xRange),\n        minYRange = axisMin(_d.yRange),\n        xFlipped = isAxisFlipped(_d.xRange),\n        yFlipped = isAxisFlipped(_d.yRange),\n        xDistance = _d.xDistance,\n        yDistance = _d.yDistance,\n        xScale = _d.xScale,\n        yScale = _d.yScale,\n        data = isArray(this.d) ? { data: [ ...this.d ] } : { ...this.d },\n        dataKeys = Object.keys(data),\n        dataLength = dataKeys.length;\n\n    // two helper funcs to get X,Y position of circle and line shapes,\n    // used by drawCircle() and drawLines()\n    const getX = (px, n) => xFlipped\n      ? (px||px===0) ? x+w-(xDistance*px)-(xDistance*minXRange) : x+w-(xDistance*n)*xScale\n      : (px||px===0) ? x+(xDistance*px)-(xDistance*minXRange) : x+(xDistance*n)*xScale;\n\n    const getY = (py, n) => yFlipped\n      ? (py||py===0) ? y-h+(yDistance*py)-(yDistance*minYRange) : y-h+(yDistance*n)*yScale\n      : (py||py===0) ? y-(yDistance*py)+(yDistance*minYRange) : y-(yDistance*n)*yScale\n\n\n    let lineCache = {},\n        drawLines = () => {},\n        stackedBarOffsets = {},\n        stackedLineOffsets = {};\n\n    // Now loop over the users data:\n    // 'dataKeys' is the top-level keys in our data, (usually categories, countries, etc)\n    //\n    dataKeys.forEach((key, i) => {\n      const prevData = data[dataKeys[i-1]], // if needed\n            nextData = data[dataKeys[i+1]]; // if needed\n\n      let currentPieDeg = -90;\n\n      stackedBarOffsets[i] = [];\n\n      // Now loop over this dataset, and prepare drawing functions for each\n      // data point in the set.\n      //\n      data[key].forEach((d, n) => {\n        // Lets create our drawing methods here:\n        //\n        // In d3, to make it assume shape x/y/w/h defaults, you join your data\n        // to an attr, but must often explictly define the other attrs as defaults.\n        //\n        // Let's make it easier - only define the attrs you wanna join to your data:\n\n        // Drawing lines:\n        // - just cache the line points, we'll draw them later\n        const drawLine = (opts) => {\n          lineCache[key] = lineCache[key] || [];\n          lineCache[key].push(opts);\n        }\n\n        // Drawing circles\n        // - give either cx or cy, plus any other params you wanna set\n        const drawCircle = ({ px, py, radius, start, end, rotate = 0, style }) => {\n          if (!px && !py) return;\n          const paramX = getX(px, n),  paramY = getY(py, n);\n          if (style) {\n            this.save();\n            setStyle(this, style);\n          }\n          this.beginPath();\n          this.arc(\n            paramX,\n            paramY,\n            // radius\n            radius||5,\n            // start angle (in radians)\n            deg2rad(start+rotate)||0,\n            // end angle (in radians)\n            deg2rad(end+rotate)||Math.PI*2\n          );\n          // go to center of circle, and _then_ close the path (creates\n          // a \"pie\" or \"pacman\" shape, if degrees < 360)\n          this.lineTo(paramX, paramY);\n          this.closePath();\n          this.stroke();\n          this.fill();\n          this.closePath()\n          if (style) this.restore();\n        };\n\n        // Drawing pie slices\n        // - just pass in the slice, all others are optional\n        const drawPieSlice = ({ slice = 0, totalDegrees = 360, px, py, radius = w-(w/100*50), innerRadius = 0, rotation = 0, style }) => {\n          // dont draw anything if blank data\n          if (Object.keys(d).length <= 5) return;\n\n          const paramX = px||x+w/2,\n                paramY = py||y-h/2,\n                // get name of key/prop that \"slice\" represents:\n                // dumb method - just find a prop in `d` with a matching value\n                prop = Object.keys(d).find(k=>d[k]===slice),\n                // get the sum total in our dataset for that prop\n                sumTotal = getSumTotal(data[key], prop),\n                sliceAsPercOfTotal = slice/(sumTotal)*100,\n                sliceInDeg = sliceAsPercOfTotal*totalDegrees/100;\n\n          if (style) {\n            this.save();\n            setStyle(this, style);\n          }\n          this.beginPath();\n          this.arc(\n            paramX,\n            paramY,\n            radius,\n            // start angle (in radians)\n            deg2rad(currentPieDeg-rotation),\n            // end angle (in radians)\n            deg2rad(currentPieDeg+sliceInDeg-rotation),\n          );\n          // go to center of circle, and _then_ close the path (creates a \"pie\"\n          // or \"pacman\" shape, if degrees < 360)\n          this.lineTo(paramX, paramY);\n          this.fill();\n          this.closePath();\n          if (innerRadius) {\n            this.save();\n            this.globalCompositeOperation = \"destination-out\";\n            this.beginPath();\n            this.arc(paramX, paramY, innerRadius, 0, Math.PI*2);\n            this.moveTo(radius, 0);\n            this.fill();\n            this.restore();\n          }\n          currentPieDeg += sliceInDeg;\n          if (style) this.restore();\n        }\n\n        // Drawing arc/gauge slices\n        // - just pass in the slice, all others are optional\n        // - a wrapper around pieSlice, with different defaults\n        const drawArcSlice = ({\n          slice = 0,\n          totalDegrees = 180,\n          px,\n          py,\n          radius,\n          innerRadius = 50,\n          rotation = 90,\n          style,\n        }) => {\n          drawPieSlice({\n            slice,\n            totalDegrees,\n            px,\n            py,\n            radius,\n            innerRadius,\n            rotation,\n            style,\n          });\n        };\n\n        // Draw bars\n        // - pass in either height or width, not both!\n        //   - pass in height to draw vertical bars\n        //   - pass in width to draw horizontal bars\n        // - bars are grouped side by side, by default, but can be stacked\n        const drawBar = ({ height, width, offset = 0, stacked = false, padding = 12, style }) => {\n          const isVertical = (height||height===0),\n                distance   = isVertical ? xDistance : yDistance,\n                barPadding = distance/100*padding,\n                barWidth   = stacked ? distance-barPadding : (distance/dataLength)-(barPadding/2),\n                barHeight  = isVertical ? height : width,\n                centered   = barWidth*dataLength/2;\n\n          // accumulate the previous bar heights\n          let totalHeight = 0;\n          if (stacked) {\n            Object.keys(stackedBarOffsets).forEach(k => {\n              // account for \"padded\" data when grabbing previous bar heights:\n              // @TODO - work out why this startNum check even works...\n              //       - and double check it actually does!\n              const startNum = stackedBarOffsets[k].length === 0 ? n-1 : n;\n              totalHeight += stackedBarOffsets[k][startNum]||0;\n            });\n          }\n          // set the stacked bar offset position\n          let stackedBarOffset = prevData ? totalHeight*(isVertical ? yDistance : xDistance) : 0;\n\n          if (style) {\n            this.save();\n            setStyle(this, style);\n          }\n          this.beginPath();\n          this.fillRect(\n            // x\n            xFlipped\n              ? isVertical\n                ? stacked ? x+w-(xDistance*n)-(barWidth/2) : x+w-(barWidth*i)-(xDistance*n)\n                : stacked ? x+w-stackedBarOffset : x+w\n              : isVertical\n                ? stacked ? x+(xDistance*n)-(barWidth/2) : x+(barWidth*i)+(xDistance*n)-centered\n                : x+stackedBarOffset+(xDistance*offset),\n            // y\n            yFlipped\n              ? isVertical\n                ? y-h+(stacked ? stackedBarOffset : 0-(yDistance*offset))\n                : stacked ? y-h+(yDistance*n)+barWidth/2 : y-h+(barWidth*i)+(yDistance*n)\n              : isVertical\n                ? y-(stacked ? stackedBarOffset : 0)+(yDistance*offset) // NOTE: `offset` used for candlesticks\n                : stacked ? y-(yDistance*n)+barWidth/2 : y-barWidth*i-(yDistance*n)+centered,\n            // w\n            xFlipped\n              ? isVertical\n                ? stacked ? xDistance-barPadding: barWidth\n                : -(xDistance*(stacked ? barHeight : width))+(xDistance*minXRange)\n              : isVertical\n                ? stacked ? xDistance-barPadding: barWidth\n                : (xDistance*barHeight)-(stacked ? 0 : xDistance*minXRange),\n            // h\n            yFlipped\n              ? isVertical\n                ? yDistance*(stacked ? barHeight : height)-(stacked ? 0 : yDistance*minYRange)\n                : -barWidth\n              : isVertical\n                ? -yDistance*(stacked ? barHeight : height)+(stacked ? 0 : yDistance*minYRange)\n                : -barWidth\n          );\n          // store all bar heights for this dataset\n          if (stacked) stackedBarOffsets[i].push(barHeight);\n          this.stroke();\n          this.closePath();\n          if (style) this.restore();\n        }\n\n        const drawCandle = ({ open, close, low, high, green, red, padding = 80, style }) => {\n          const length = Math.abs(open - close),\n                offset = length - (close > open ? close : open),\n                lineLength = high - low,\n                px = xFlipped ? x+w-(xDistance*n) : x+(xDistance*n);\n\n          if (high-low > 0) {\n            this.beginPath();\n            this.save();\n            setStyle(this, style);\n            this.moveTo(px, getY(high, n));\n            this.lineTo(px, getY(low, n)-1); // -1 just to make a little nicer visual gap with the axis..\n            this.stroke();\n            this.restore();\n          }\n\n          drawBar({\n            height: length,\n            offset,\n            padding,\n            style: {\n              ...style,\n              fill: close > open ? green||'#0d0' : red||'#d00',\n            },\n          });\n        };\n\n        // add drawing methods to `data[key][n][shape]`\n        d['circle'] = drawCircle;\n        d['bar'] = drawBar;\n        d['pie'] = drawPieSlice;\n        d['arc'] = drawArcSlice;\n        d['line'] = drawLine;\n        d['candle'] = drawCandle;\n      });\n      // now run the given func on the decorated data\n      fn(data[key], key, i);\n      //\n    });\n\n    // Draw lines\n    // - draws the lines that were merely cached by .line()\n    // - takes its the x,y point to draw from the lineCache object\n    drawLines = () => {\n      const cachedKeys = Object.keys(lineCache);\n      if (cachedKeys.length < 1) return;\n      let paramX, paramY, isStacked, areaFill;\n      this.save();\n      cachedKeys.forEach((key, i) => {\n        stackedLineOffsets[key] = [];\n        lineCache[key].forEach((line, l) => {\n          const { px, py, stacked, smooth, style } = line;\n          // styling\n          if (style) setStyle(this, style);\n          // accumulate the previous line heights\n          let totalHeight = 0;\n          let nextTotalHeight = 0;\n          if (stacked) {\n            Object.keys(stackedLineOffsets).forEach(k => {\n              totalHeight += stackedLineOffsets[k][l]||0;\n              nextTotalHeight += stackedLineOffsets[k][l+1]||0;\n            });\n          }\n          paramX = getX(px, l);\n          paramY = getY(stacked ? py+totalHeight : py, l);\n          areaFill = style.fillStyle||style.fill;\n          isStacked = stacked;\n          if (l === 0) {\n            this.beginPath();\n            if (areaFill) {\n              xFlipped\n                ? this.moveTo(x+w, yFlipped ? y-h : y)\n                : this.moveTo(paramX, paramY);\n            }\n          }\n          if (px||py) {\n            if (smooth) {\n              const nextLine = lineCache[key][l+1];\n              if (nextLine) {\n                const nextPx = getX(nextLine.px, l+1),\n                      nextPy = getY(nextLine.py+nextTotalHeight, l+1),\n                      x_mid = (paramX + nextPx) / 2,\n                      y_mid = (paramY + nextPy) / 2,\n                      cp_x1 = (x_mid + paramX) / 2,\n                      cp_x2 = (x_mid + nextPx) / 2;\n\n                this.quadraticCurveTo(cp_x1, paramY, x_mid,  y_mid);\n                this.quadraticCurveTo(cp_x2, nextPy, nextPx, nextPy);\n              }\n            } else {\n              this.lineTo(paramX, paramY);\n            }\n          }\n          // store all line heights for this dataset\n          if (stacked) stackedLineOffsets[key].push(py);\n        });\n        this.stroke();\n        // if filling the area under the line\n        if (areaFill) {\n          this.save();\n          this.lineTo(paramX, yFlipped ? y-h : y);\n          if (!xFlipped) this.lineTo(x,yFlipped ? y-h : y);\n          if (isStacked) this.globalCompositeOperation = \"destination-over\"\n          this.globalAlpha = 0.75;\n          this.fill();\n          this.restore();\n        }\n        // always close path\n        this.closePath();\n      });\n\n      this.restore();\n      lineCache = {};\n    }\n    drawLines();\n  },\n\n  margin: function(t,b,l,r){\n    this.margin = {\n      top: t,\n      bottom: b,\n      left: l,\n      right: r,\n    }\n  },\n\n  setStyle: function(obj) {\n    setStyle(this, obj);\n  },\n\n  xAxis: function({ range, scale = 1, yPos = 0, tickLength = 5, label = false, labelBelow = true, tickLabelCentered = false, tickCentered = true, tickLabels, style, tickStyle }) {\n    const { w, h, x, y } = getDimensions(this),\n          flippedAxis = range[0] > range[1],\n          theRange = getRange(range),\n          labelLength = getTextWidth(this, label),\n          labelHeight = getTextHeight(this, label),\n          distanceBetweenTicks = Math.abs(w / theRange);\n\n    this._d.xRange = range;\n    this._d.xScale = scale;\n    this._d.xDistance = Math.round(distanceBetweenTicks);\n    this._d.xLabels = [];\n\n    drawAxisTicks(this, { w, h, x, y }, 'x', yPos, yPos <= 50 ? tickLength : -tickLength, tickCentered, distanceBetweenTicks, scale, tickStyle);\n    drawAxisLine(this,  { w, h, x, y }, 'x', yPos, style);\n\n    for (let i=0, p=0; i<=(w+distanceBetweenTicks/2); i+=distanceBetweenTicks*scale) {\n      const tickLabel = getTickLabel(range, flippedAxis, p, scale, tickLabels),\n            tickLabelLength = getTextWidth(this, tickLabel),\n            py = yPos <= 50 ? (y+labelHeight+(labelHeight/2))-(h/100*yPos) : y-(h/100*yPos)-labelHeight,\n            px = flippedAxis\n              ? tickLabelCentered ? x+w-i-(tickLabelLength/2) : x+w-i\n              : tickLabelCentered ? x+i-(tickLabelLength/2) : x+i;\n\n      this._d.xLabels.push(tickLabel);\n      this.fillText(tickLabel, px, py);\n      p++;\n    }\n\n    if (label) {\n      this.fillText(\n      //text\n      label,\n      //x\n      (x+w/2)-(labelLength/2),\n      //y\n      labelBelow\n        ? y+(labelHeight*3)\n        : y-h-(labelHeight*2)-(labelHeight/2)\n      );\n    }\n  },\n\n  yAxis: function({ range, scale = 1, xPos = 0, tickLength = 5, label = false, labelLeft = true, tickCentered = true, tickLabels, style, tickStyle }) {\n    const { w, h, x, y } = getDimensions(this),\n          flippedAxis = range[0] > range[1],\n          theRange = getRange(range),\n          labelWidth = getTextWidth(this, label),\n          labelHeight = getTextHeight(this, label),\n          distanceBetweenTicks = Math.abs(h / theRange);\n\n    let maxLabelWidth = 0;\n\n    this._d.yRange = range;\n    this._d.yScale = scale;\n    this._d.yDistance = Math.round(distanceBetweenTicks);\n    this._d.yLabels = [];\n\n    drawAxisTicks(this, { w, h, x, y }, 'y', xPos, xPos <= 50 ? tickLength : -tickLength, tickCentered, distanceBetweenTicks, scale, tickStyle);\n    drawAxisLine(this,  { w, h, x, y }, 'y', xPos, style);\n\n    for (let i=0, p=0; i<=h; i+=distanceBetweenTicks*scale){\n      const tickLabel = getTickLabel(range, flippedAxis, p, scale, tickLabels),\n            tickLabelWidth = getTextWidth(this, tickLabel),\n            py = !flippedAxis ? y-i+4 : (y-h)+i+2,\n            px = (xPos <= 50)\n              ? x-labelHeight-(tickLabelWidth)+(w/100*xPos)\n              : x+(w/100*xPos)+labelHeight;\n\n      if (tickLabelWidth >= maxLabelWidth) maxLabelWidth = tickLabelWidth;\n      this._d.yLabels.push(tickLabel);\n      this.fillText(tickLabel, px, py);\n      p++;\n    }\n\n    if (label) {\n      this.fillText(\n        // text\n        label,\n        // x\n        labelLeft\n          ? x-labelWidth-(labelHeight*2)-(maxLabelWidth)\n          : xPos <= 50 ? x+w+labelHeight : x+w+(labelHeight*2)+(maxLabelWidth),\n        // y\n        y+4-(h/2)\n      );\n    }\n  },\n};\n\nconst extraMethodNames = Object.keys(extraMethods);\n\n\n// ...Now the main function to export\n\n/**\n* @class Canvas Context2D Wrapper.\n* @param {CanvasRenderingContext2D} origCtx\tCanvas Context2D that will be wrapped.\n* @param {Component} c\tthe @scottjarvis/component to which the ctx is attached (optional)\n*/\nconst Chart = function(origCtx, c) {\n  let n = ctxMethods.length;\n  let curProp;\n\n  /**\n   * Reference to Canvas Rendering Context 2D.\n   * @type CanvasRenderingContext2D\n   */\n  this.context = origCtx;\n\n  //wrap methods\n  while(n--) {\n  \tcurProp = ctxMethods[n];\n  \tthis[curProp] = chainMethod(origCtx[curProp], origCtx, this);\n  }\n\n  // wrap the extra methods\n  n = extraMethodNames.length;\n  while(n--) {\n  \tcurProp = extraMethodNames[n];\n  \tthis[curProp] = chainMethod(extraMethods[curProp], origCtx, this);\n  }\n\n  //convert properties into methods (getter/setter)\n  n = ctxProps.length;\n  while(n--) {\n  \tcurProp = ctxProps[n];\n  \tthis[curProp] = chainProperty(curProp, origCtx, this);\n  }\n\n  // the above code replaces context properties with methods in our new\n  // context, so put back the reference to the canvas element, cos we want it\n  this.canvas = origCtx.canvas;\n\n\n  // add more methods to the extended context - they're added here cos they're\n  // nested/namespaced under ctx.image.* and ctx.video.* and the above\n  // loops that make methods chainable don't handle nested objects\n\n  this.context.margin = {\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0,\n  };\n\n  return;\n};\n\n\nexport default Chart;\n"],"names":["ctxMethods","split","ctxProps","chainMethod","fn","scope","chainReturn","apply","arguments","chainProperty","propName","value","PIXEL_RATIO","window","devicePixelRatio","isFn","v","isArray","Array","isAxisFlipped","range","axisMin","getRange","deg2rad","deg","Math","PI","setStyle","ctx","obj","fixedProp","prop","getDimensions","c","canvas","m","margin","w","width","right","left","h","height","top","bottom","x","y","xRange","yRange","xScale","yScale","xLabels","yLabels","xDistance","yDistance","_d","drawAxisLine","dimensions","whichAxis","pos","style","save","strokeStyle","stroke","beginPath","py","moveTo","lineTo","px","closePath","restore","drawAxisTicks","tickLength","tickCentered","distanceBetweenTicks","scale","tickStyle","max","centered","i","round","getTickLabel","flippedAxis","labels","abs","autoLabel","tickLabel","getTextWidth","t","measureText","getTextHeight","metrics","fontBoundingBoxAscent","fontBoundingBoxDescent","extraMethods","clear","resetTransform","this","setTransform","clearRect","size","a","s","objectFit","contextType","useData","data","prevData","d","drawEach","minXRange","minYRange","xFlipped","yFlipped","dataKeys","Object","keys","dataLength","length","getX","n","getY","lineCache","drawLines","stackedBarOffsets","stackedLineOffsets","forEach","key","currentPieDeg","drawPieSlice","slice","totalDegrees","radius","innerRadius","rotation","paramX","paramY","find","k","sumTotal","array","filter","item","reduce","prev","cur","getSumTotal","sliceInDeg","arc","fill","globalCompositeOperation","drawBar","offset","stacked","padding","isVertical","distance","barPadding","barWidth","barHeight","totalHeight","startNum","stackedBarOffset","fillRect","push","start","end","rotate","opts","open","close","low","high","green","red","cachedKeys","isStacked","areaFill","line","l","smooth","nextTotalHeight","fillStyle","nextLine","nextPx","nextPy","x_mid","y_mid","cp_x1","cp_x2","quadraticCurveTo","globalAlpha","b","r","xAxis","yPos","label","labelBelow","tickLabelCentered","tickLabels","theRange","labelLength","labelHeight","p","tickLabelLength","fillText","yAxis","xPos","labelLeft","labelWidth","maxLabelWidth","tickLabelWidth","extraMethodNames","origCtx","curProp","context"],"mappings":"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"}