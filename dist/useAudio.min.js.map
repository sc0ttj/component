{"version":3,"file":"useAudio.min.js","sources":["../src/useAudio.js"],"sourcesContent":["/**\n  The useAudio() function uses lots of code and ideas from these projects:\n\n    - https://github.com/kittykatattack/sound.js\n    - https://github.com/madebywild/audioFX\n\n  To add more features or extend useAudio, take a look at\n    - https://github.com/chrisguttandin/standardized-audio-context (a \"ponyfill\" to improve cross-browser compatibility)\n    - https://github.com/mohayonao/pseudo-audio-param (automation of props over time)\n    - https://github.com/mohayonao/adsr-envelope\n    - https://github.com/rsimmons/fastidious-envelope-generator\n    - https://github.com/Theodeus/tuna\n\n*/\n\n\n\n/**\n * useAudio - main function, creates audio objects from a library of sounds, such as mp3 files\n *\n * param sounds - an Object containing the library of sounds to create (required)\n * param c      - the Component to attach the library of sounds to (optional)\n *\n */\nconst useAudio = function(sounds, c) {\n  // if not in browser, exit\n  if (!document || !window || typeof sounds !== 'object') return;\n\n  const isArr = Array.isArray;\n  // a \"no operation\" function, used as a default setting for some callbacks\n  const noop = function noop(){ return; };\n  // minimin vol (exponentialRampToValue method of web audio API gain nodes\n  // doesn't like zero as a input, for some reason)\n  const minGain = 0.00001;\n\n  // create the global \"audio context\", or hook into an existing one\n  const ctx = window.AudioContext || window.webkitAudioContext;\n  window.audioCtx = window.audioCtx ? window.audioCtx : new ctx();\n\n  // normalize browser syntax\n  if (!audioCtx.createGain) audioCtx.createGain = audioCtx.createGainNode;\n  if (!audioCtx.createDelay) audioCtx.createDelay = audioCtx.createDelayNode;\n  // if (!audioCtx.createScriptProcessor) audioCtx.createScriptProcessor = audioCtx.createJavaScriptNode;\n\n\n  // the library of the sounds Nodes returned by this function\n  const library = {};\n  // vars used as re-usable holders, accessed in various functions, and always\n  // represent the current item in the list of sounds passed into useAudio\n  let name = null;\n  let src = null;\n  let filters = false;\n  // the list of supported filters, listed in the order they are connected..\n  // note that not all of these need to be enabled\n  const filterList = [\n   'gain', 'panning', 'reverb', 'equalizer', 'lowpass',\n   'lowshelf', 'peaking', 'notch', 'highpass', 'highshelf', 'bandpass',\n   'allpass', 'compression', 'analyser'\n  ];\n  // store audio buffer objects in here, ready to be put into bufferSourceNodes,\n  // which are high performance \"fire and forget\" audio nodes with a start()\n  // method called by play() method\n  const cache = {};\n  // set the number of files that need to be loaded\n  window.totalFiles = window.totalFiles ? window.totalFiles : 0;\n  window.totalFiles += Object.keys(sounds).length;\n  // set the number of files loaded so far\n  window.loadedFiles = window.loadedFiles ? window.loadedFiles : 0;\n\n\n\n  // download the given audio file, decode it, save it as a buffer into\n  // cache[name], then run the given callback, which is fileLoaded()\n  const loadFile = (url, item) => {\n    // if we already cached it, use the cached one\n    if (cache[name]) {\n      fileLoaded(cache[name]);\n      return;\n    }\n    // else, create a AJAX request\n    const req = new XMLHttpRequest();\n    req.open(\"GET\", url);\n    req.responseType = \"arraybuffer\";\n    // once req is completed, run this func\n    req.onload = function() {\n      // decode the response data into a buffer object, and pass it to callback\n      let d = req.response;\n      audioCtx.decodeAudioData(d, function(buffer) {\n        // run onloaded the callback\n        fileLoaded(buffer, item);\n      });\n    };\n    // report the download progress\n    req.onprogress = function (e) {\n      let percent = 0;\n      if (e.lengthComputable) {\n        percent = (e.loaded / e.total) * 100;\n      }\n      document.dispatchEvent(new CustomEvent(\"audioProgress\", { detail: { percent, url } }));\n      return percent;\n    };\n    // send the request\n    req.send();\n  };\n\n\n\n  // the callback passed into loadFile, run once the given file has loaded,\n  // receives the file as a buffer\n  const fileLoaded = (buffer, item) => {\n    // cache the buffer object\n    cache[name] = cloneBuffer(buffer);\n    // add the current sound to the library of sounds to be returned (namely,\n    // add library[name] and populate it with all the sounds props)\n    library[name] = addToLibrary(item);\n    // add the .settings({ ... }) method, for updating a sounds props, to the\n    // library collection itself - calling it will update all sounds in the\n    // library object\n    library['settings'] = (props, cb) => {\n      // update all sounds\n      Object.keys(library).forEach(audioObj => {\n        if (!library[audioObj]) return;\n        if (audioObj === 'settings') return;\n        // update the sound object with the given properties\n        if (library[audioObj].settings) library[audioObj].settings(props);\n      });\n      // then run the callback, if any\n      if (typeof cb === 'function') cb(library[audioObj].state);\n      // make it chainable\n      return library;\n    };\n\n    // add to count of files now loaded and check if all done\n    checkAllFilesLoaded();\n    // autoplay if needed\n    if (library[name].autoplay === true) library[name].play();\n  };\n\n\n  // count each file downloaded via AJAX, check if num loaded matches total\n  const checkAllFilesLoaded = () => {\n    window.loadedFiles += 1;\n    // check if all files loaded\n    if (window.totalFiles === window.loadedFiles) {\n      document.dispatchEvent(new CustomEvent(\"audioLoaded\", { detail: library }));\n    }\n  };\n\n  // clone a buffer object, so we can save it to the cache before playing it\n  // (after which the buffer normally disappears and is garbage collected)\n  const cloneBuffer = inBuffer => {\n    let outBuffer = audioCtx.createBuffer(\n      inBuffer ? inBuffer.numberOfChannels : 2,\n      inBuffer ? inBuffer.length : 0,\n      inBuffer ? inBuffer.sampleRate : audioCtx.sampleRate\n    );\n    for (var i = 0, c = inBuffer.numberOfChannels; i < c; ++i) {\n      let od = outBuffer.getChannelData(i),\n        id = inBuffer.getChannelData(i);\n      od.set(id, 0);\n    }\n    return outBuffer;\n  }\n\n\n\n  // create the sound Object and add it to the library that we return\n  const addToLibrary = (item) => {\n    // library is the main object returned by useAudio(), and \"name\" is the\n    // name of the current sound object being added (\"name\" is defined in main\n    // loop near end of the script)\n\n    const obj = {\n      // set some properties\n      name,\n      src, // should be a string (URL to audio file), another sound object, or an array of sound objects\n      // the main methods\n      play,\n      playFrom,\n      pause,\n      fadeIn,\n      fadeOut,\n      rapidFire,\n      stop,\n      mute,\n      unmute,\n      connectTo,\n      // callbacks\n      onPlay: item[1].onPlay || noop,\n      onPause: item[1].onPause || noop,\n      onResume: item[1].onResume || noop,\n      onStop: item[1].onStop || noop,\n      onChange: item[1].onChange || noop,  // fired when a prop in state changes or sound is -reconnected\n      // set input node:\n      input: audioCtx.createBufferSource(),\n      // set output node:\n      // - output to the default output of the Audio Context all our sounds use\n      output: audioCtx.destination,\n      // set audio nodes:\n      // the actual audio nodes that will be connected and form the audio graph..\n      // this will be created by the play() method, and will include input/output\n      // above... NOTE: if defined, equaliser nodes end up in their own array,\n      // separate from this list of audio nodes, so that we can keep track of\n      // which nodes are used for what, and that the equaliser can be adjusted\n      // as a single \"thing\", via settings\n      audioNodes: [],\n      // set audio properties:\n      // all audio nodes have these settings applied to them where relevant,\n      // and the play(), pause() etc  methods check for and respect these\n      // settings. All filter settings will be added to state too. The state\n      // should be updated using the mySound.settings({ ... }) method.\n      state: {\n        isPlaying: false,                         // boolean\n        volume: item[1].volume || 1,              // 0 is slient, 1 is 100%, 2 is 200%\n        muted: item[1].muted || false,            // false is not muted\n        autoplay: item[1].autoplay || false,      // boolean\n        loop: item[1].loop || false,              // boolean\n        playbackRate: item[1].playbackRate || 1,  // 1 is normal speed, 2 is double speed\n        //detune: item[1].detune || 0,              // 1200 is up 1 octave, -1200 is down 1 octave\n        startTime: item[1].startTime || 0,        // start time of the sound, when played\n        startOffset: item[1].startOffset || 0,    // used to help track pause/resume/play times\n        //fadeIn: item[1].fadeIn || 0,              // duration in seconds\n        //fadeOut: item[1].fadeOut || 0,            // duration in seconds\n      },\n      // this is the mySound.settings() method... it allows updating the props\n      // of individual sounds with mySound.settings({ ... }) - pass in only\n      // the options you want to change.\n      settings: function(props, cb) {\n        // check if prop relates to an existing audio node or not\n        Object.keys(props).forEach(key => {\n          const rebuildNodes = filterList.indexOf(key) !== -1 && isDisabled(obj.state[key]) !== isDisabled(props[key]);\n          if (rebuildNodes) {\n            obj.state = { ...obj.state, ...props };\n            obj.audioNodes = createNodes(obj);\n            connectNodes(obj);\n            if (obj.state.isPlaying) obj.playFrom(audioCtx.currentTime);\n          }\n        });\n        obj.state = { ...obj.state, ...props };\n        randomiseSound(obj);\n        // update settings of each audio node\n        setupNodesFor(obj);\n        if (typeof cb === 'function') cb(obj.state);\n        // setting have changed, call the relevant callback\n        obj.onChange(obj.state);\n        // return the whole sound object\n        return obj;\n      },\n    };\n    // create all audio nodes that we need\n    obj.audioNodes = createNodes(obj);\n    return obj;\n  }\n\n\n  const randomiseSound = (soundObj) => {\n    const s = soundObj.state;\n    // randomise sound if need be\n    if (typeof s.randomization === 'object') {\n      const r = s.randomization;\n      if (r.volume) s.volume = s.volume + (Math.random() * r.volume);\n      if (r.playbackRate) s.playbackRate = s.playbackRate + (Math.random() * r.playbackRate);\n      if (r.startOffset) s.startOffset = s.startOffset + 1 * (0.01 + Math.random() * r.startOffset);\n      if (r.delay && getAudioNode(soundObj, 'delay')) s.delay = s.delay * (0.01 + Math.random() * r.delay);\n    }\n  }\n\n  // for each audio node in soundObj, apply settings from state - this function\n  // is called by the setting() method and play(), etc.\n  const setupNodesFor = (soundObj) => {\n    const s = soundObj.state;\n    // configure the input node\n    soundObj.input.loop = s.loop;\n    soundObj.input.playbackRate.value = s.playbackRate;\n    // for each sound property in soundObject.state\n    Object.keys(s).forEach(key => {\n      const nodeType = key === 'volume' ? 'gain' : key;\n      // get the audio node of type 'nodeType'\n      let node = getAudioNode(soundObj, nodeType);\n      // get opts/values of the current prop (key) in sound objects state\n      // set the value based on the property (key) in the state\n      if (node && !isDisabled(s[key])) {\n        setNodeProps(soundObj, node, s[key]);\n      }\n    });\n  };\n\n\n  // helper func - check if an audio node is disabled in the options\n  const isDisabled = n => n === undefined || n === null || n === false;\n\n  // create all audio nodes defined in sound settings, and return them in an array\n  const createNodes = (soundObj) => {\n    // define a list of all audio nodes needed in the chain\n    const graph = [\n      soundObj.input, // the input node\n    ];\n    // get filter opts\n    const filterNodes = {};\n    // always create a gain node, as they're not listed with the other filters\n    // in the config pass to us by user\n    const allFilters = {\n      gain: soundObj.state.volume,\n      ...filters,\n      ...soundObj.state,\n    };\n    // create a filter node for each one defined\n    Object.keys(allFilters).forEach(type => {\n      // get the options for this filter\n      const opts = allFilters[type];\n      // skip filter is no valid settings given\n      if (isDisabled(opts)) return;\n      // create filter and add to a list of all enabled filters\n      filterNodes[type] = createFilterNode(soundObj, type, opts);\n      // add filter settings to state\n      const prop = type === 'gain' ? 'volume' : type;\n      soundObj.state[prop] = opts;\n      if (filterNodes[type]) {\n        // set audio nodes props to match values in the sounds state\n        setNodeProps(soundObj, filterNodes[type], opts);\n      }\n    });\n    // now sort all filterNodes into the \"proper\" order\n    filterList.forEach(type => {\n      // attach the node in the list (type)\n      if (filterNodes[type] && type !== 'equalizer') {\n        graph.push(filterNodes[type]);\n      }\n      // add all the equalizer nodes, which are not in filterNodes,\n      // but in the soundObj.eq array\n      else if (type === 'equalizer' && isArr(soundObj.eq)) {\n        soundObj.eq.forEach(node => graph.push(node));\n      }\n    });\n    // add the output node to the graph\n    graph.push(soundObj.output)\n    return graph;\n  };\n\n\n  // create filter nodes of given \"type\", with options \"o\" for soundObject \"s\"\n  const createFilterNode = (s, type, o) => {\n    let n = undefined; // the node to return\n    switch (type) {\n      case 'gain':\n      case 'volume':\n        n = audioCtx.createGain();\n        break;\n      case 'panning':\n        if (!audioCtx.createStereoPanner) {\n          n = audioCtx.createPanner();\n        } else {\n          n = audioCtx.createStereoPanner();\n        }\n        break;\n      //case 'panning3d':\n      //  n = audioCtx.createPanner();\n      //  break;\n      case 'delay':\n        n = audioCtx.createDelay();\n        break;\n      case 'lowpass':\n      case 'highpass':\n      case 'bandpass':\n      case 'allpass':\n      case 'lowshelf':\n      case 'highshelf':\n      case 'peaking':\n      case 'notch':\n        n = audioCtx.createBiquadFilter();\n        break;\n      case 'equalizer':\n        // we need to return an \"audio node\" to put into our graph array, but\n        // we don't wanna create only one node for our equalizer, so\n        // return a fake node into the list, of type \"equalizer\", and add\n        // all the nodes we need to a separate array - we'll parse the fake\n        // node of type \"equalizer\" in setNodeProps(), and access it's array\n        // of nodes there\n        n = {\n          type: 'equalizer',\n        };\n        // create the array that holds each filter node (each is a eq band)\n        s.eq = [];\n        // each obj in o is a filter settings obj, so create an audio node\n        // for each one, with the correct type\n        //if (o && o.length && o.length > 0) {\n        o.forEach((eq, i) => {\n          const eqNode = audioCtx.createBiquadFilter();\n          if (i === 0) {\n            eqNode.type = 'lowpass';\n          }\n          else if (i === (o.length - 1)) {\n            eqNode.type = 'highpass';\n          }\n          else {\n            eqNode.type = 'peaking';\n          }\n          // add each audio node to the \"equalizer\" array\n          s.eq.push(eqNode);\n        });\n        //}\n        break;\n      case 'reverb':\n        n = audioCtx.createConvolver();\n        break;\n      case 'analyser':\n        n = audioCtx.createAnalyser();\n        break;\n      case 'compression':\n        n = audioCtx.createDynamicsCompressor();\n        break;\n      default:\n        break;\n    }\n    // set a type (used in createNodes() to filter node list)\n    if (n) n.type = type;\n    // return the audio node\n    return n;\n  };\n\n\n\n  // TODO smoother settings changes: also use \"linearRampToValueAtTime\", or \"exponentialRampToValueAtTime\"\n  // TODO clamp values between the min/max of the AudioParam type:\n  //        - gain: min  0, max  1\n  //        - pan: min  -1, max  1\n  //        - ..\n  // set the props of the given audio node (n) to match the values in the\n  // current sounds state options (o) for the given sound object (s)\n  const setNodeProps = (s, n, o) => {\n    const type = n.type;\n    const ct = audioCtx.currentTime;\n\n    // helper functions, to check and set filter values\n    const has = prop => typeof o === 'number' || typeof o[prop] === 'number';\n    const setVal = (prop, v) => n[prop].setValueAtTime(v, ct);\n    const setFreq = () => n.frequency.setValueAtTime(o.freq, ct);\n    const setGain = () => n.gain.setValueAtTime(o.gain, ct);\n    const setQ = () => n.Q.setValueAtTime(o.q, ct)\n\n    switch (type) {\n      case 'volume':\n      case 'gain':\n        // dont let \"v\" go below zero\n        let v = o <= 0 ? minGain : o;\n        // set to zero if muted\n        if (s.state.mute === true) v = minGain;\n        // update the node and state\n        //s.state.volume = v;\n        n.gain.setValueAtTime(v, ct);\n        //n.gain.value = v;\n        break;\n      case 'panning':\n        if (!audioCtx.createStereoPanner) {\n          //Panner objects accept x, y and z coordinates for 3D\n          //sound. However, because we're only doing 2D left/right\n          //panning we're only interested in the x coordinate,\n          //the first one. However, for a natural effect, the z\n          //value also has to be set proportionately.\n          const y = 0;\n          const z = 1 - Math.abs(o);\n          n.setPosition(o, y, z);\n          n.panValue = o;\n        } else {\n          setVal('pan', typeof o === 'number' ? o : 0);\n        }\n        //s.state.panning = o;\n        break;\n      //case 'panning3d':\n      //  // TODO\n      //  break;\n      case 'delay':\n        setVal('delayTime', typeof o === 'number' ? o : 0);\n        break;\n      case 'lowpass':\n      case 'highpass':\n      case 'bandpass':\n      case 'allpass':\n      case 'lowshelf':\n      case 'highshelf':\n      case 'peaking':\n      case 'notch':\n      \tif (has('freq')) setFreq();\n      \tif (has('gain')) setGain();\n      \tif (has('q')) setQ();\n        break;\n      case 'reverb':\n        if (o) {\n          // to allow only some props to be passed in let's merge `o` with defaults and state\n          const opts = { duration: 1, decay: 1, reverse: false, ...s.state.reverb, ...o };\n          // set the reverb\n          n.buffer = impulseResponse(opts.duration, opts.decay, opts.reverse);\n          // update state, so it contains all reverb settings\n          s.state.reverb = opts;\n        } else {\n          n.buffer = null;\n        }\n        break;\n      case 'equalizer':\n        // Note - the equalizer is an array of nodes, so don't set props on 'n',\n        // instead loop over the array and set props for each\n        if (isArr(s.eq)) {\n          // get each filter in equalizer, and apply the settings in 'opts'\n          o.forEach((opts, i) => {\n            const node = s.eq[i];\n            if (typeof opts.freq === 'number') {\n              node.frequency.value = opts.freq;\n//              node.frequency.setValueAtTime(opts.freq, ct);\n            }\n            if (typeof opts.gain === 'number') {\n              node.gain.value = opts.gain;\n//              node.gain.setValueAtTime(opts.gain, ct);\n            }\n            if (typeof opts.q === 'number') {\n              node.Q.value = opts.q;\n//              node.Q.setValueAtTime(opts.q, ct);\n            }\n          });\n        }\n        break;\n      case 'analyser':\n        if (has('fftSize')) n.fftSize = o.fftSize;\n        if (has('minDecibels')) n.minDecibels = o.minDecibels;\n        if (has('maxDecibels')) n.maxDecibels = o.maxDecibels;\n        if (has('smoothingTimeConstant')) n.smoothingTimeConstant = o.smoothingTimeConstant;\n        // now we add some useful props for visualisations to the sounds state:\n        // 1. add the analyser node to state\n        s.state.visualiser = n;\n        break;\n      case 'compression':\n        if (has('threshold')) setVal('threshold', o.threshold);\n        if (has('knee')) setVal('knee', o.knee);\n        if (has('ratio')) setVal('ratio', o.ratio);\n        if (has('attack')) setVal('attack', o.attack);\n        if (has('release')) setVal('release', o.release);\n        break;\n      default:\n        break;\n    }\n  }\n\n\n\n  // public method on soundObjs\n  // play the sound\n  const play = () => {\n    const s = library[name];\n    const state = s.state;\n    // get the input node\n    const input = audioCtx.createBufferSource();\n    // set the sound nodes buffer property to the (down)loaded sound\n    input.buffer = cloneBuffer(cache[name]);\n    // randomise sound if need be\n    randomiseSound(s);\n    // configure the input node\n    input.loop = state.loop;\n    input.playbackRate.value = state.playbackRate;\n    //input.detune.value += state.detune;\n    s.input = input;\n    // create the nodes\n    s.audioNodes = createNodes(s);\n    // now connect the audio nodes, in the proper order\n    connectNodes(s);\n    // set all properties on the relevent audio nodes to match the sounds \"state\"\n    setupNodesFor(s); // not needed...?\n    // normalize for better browser support\n    if (!input.start) input.start = input.noteOn;\n    // play the sound\n    input.start(state.startTime, state.startOffset % input.buffer.duration);\n    state.isPlaying = true;\n    // play any other sounds which have been \"connected\" to this one\n    if (isArr(s.attachedSounds)) {\n      s.attachedSounds.forEach(snd => {\n        if (!snd.state.isPlaying) snd.playFrom(audioCtx.currentTime);\n      });\n    }\n    // enable fade in if needed\n    if (typeof state.fadeIn === 'number' && state.fadeIn > 0) {\n      fadeIn(state.fadeIn);\n    }\n    // run the callbacks\n    if (state.startOffset === 0) s.onPlay(state);\n    if (state.startOffset > 0) s.onResume(state);\n  };\n\n\n  // internal method, used by play(), rapidFire(), to connect up the audio nodes\n  // before playing the sound\n  const connectNodes = (soundObj) => {\n    // connect all enabled audio nodes\n    soundObj.audioNodes.forEach((n, i) => {\n      const curr = n;\n      const next = soundObj.audioNodes[i + 1];\n      const prev =  i > 0 ? soundObj.audioNodes[i - 1] : null;\n      if (curr && next && curr.connect) {\n        // if next node is the equalizer, connect the equalizer nodes\n        if (next.type === 'equalizer') {\n          curr.connect(soundObj.eq[0]);\n          // go through each eq node and connect them up\n          soundObj.eq.forEach((eqNode, num) => {\n            if (soundObj.eq[num] && soundObj.eq[num + 1]) {\n              soundObj.eq[num].connect(soundObj.eq[num + 1]);\n            }\n          });\n        }\n        else if (prev && prev.type === 'equalizer') {\n          // if prev node was the equalizer, connect its last node up to\n          // the current node in the list\n          soundObj.eq[soundObj.eq.length - 1].connect(curr);\n          curr.connect(next);\n        } else {\n          // no need to connect to/from equaliser, so just connect up the\n          // current node \"curr\" to \"next\" node\n          curr.connect(next);\n        }\n      }\n    });\n  };\n\n  // public method on soundObjs - play a sound multiple times\n  // param \"count\"    number of times to play the sound\n  // param \"delay\"    number of milliseconds delay between in play\n  const rapidFire = (count, delay) => {\n    const num = count ? count : 3;\n    const dly = delay ? delay : 200;\n    // Make multiple sources using the same buffer and play in quick succession.\n    for (let i = 0; i < num; i++) {\n      // disable looping for this sound while rapid firing\n      const loopSetting = library[name].state.loop;\n      library[name].state.loop = false;\n      setTimeout(play, dly);\n      // restore loop setting\n      library[name].state.loop = loopSetting;\n    }\n  }\n\n\n  // public method on soundObjs\n  const pause = () => {\n      //Pause the sound if it's playing, and calculate the\n      //`startOffset` to save the current position.\n      if (library[name].state.isPlaying) {\n        library[name].state.startOffset = audioCtx.currentTime - library[name].state.startTime;\n        library[name].input.stop(0);\n        library[name].state.isPlaying = false;\n        // run the callback\n        library[name].onPause(library[name].state);\n        // pause any other sounds which have been \"connected\" to this one\n        if (isArr(library[name].attachedSounds)) {\n          library[name].attachedSounds.forEach(snd => {\n            if (snd.state.isPlaying) snd.pause();\n          });\n        }\n      }\n  };\n\n\n  // public method on soundObjs\n  const playFrom = (time) => {\n      try {\n        library[name].input.stop(0);\n      } catch (e) {};\n      library[name].state.startOffset = time;\n      library[name].play();\n  };\n\n\n  // public method on soundObjs\n  const stop = () => {\n    //Stop the sound if it's playing, reset the start and offset times,\n    //then call the `play` method again.\n    if (library[name].state.isPlaying) {\n      library[name].input.stop(0);\n      library[name].state.isPlaying = false;\n      library[name].state.startOffset = 0;\n      // run the callback\n      library[name].onStop(library[name].state);\n      // stop any other sounds which have been \"connected\" to this one\n      if (isArr(library[name].attachedSounds)) {\n        library[name].attachedSounds.forEach(snd => {\n          if (snd.state.isPlaying) snd.stop();\n        });\n      }\n    }\n  };\n\n  // public method on soundObjs\n  const mute = () => {\n    // set a previous volume, so we can restore it\n    library[name].state.prevVol = library[name].state.volume;\n    library[name].settings({\n      volume: 0,\n      muted: true,\n    });\n    // mute any other sounds which have been \"connected\" to this one\n    if (isArr(library[name].attachedSounds)) {\n      library[name].attachedSounds.forEach(snd => {\n        if (snd.state.isPlaying) snd.mute();\n      });\n    }\n  }\n\n  // public method on soundObjs\n  const unmute = () => {\n    library[name].settings({\n      volume: library[name].state.prevVol,\n      prevVol: undefined,\n      muted: false,\n    });\n    // unmute any other sounds which have been \"connected\" to this one\n    if (isArr(library[name].attachedSounds)) {\n      library[name].attachedSounds.forEach(snd => {\n        if (snd.state.isPlaying) snd.unmute();\n      });\n    }\n  }\n\n\n  // public method on soundObjs\n  // method added to sound object to let users re-connect sounds, by doing\n  // soundObj.connectTo(otherSoundObj);\n  const connectTo = (otherSound) => {\n    // update the sound props to output to the other sound\n    otherSound.attachedSounds = otherSound.attachedSounds || [];\n    otherSound.attachedSounds.push(library[name]);\n    // setting have changed, call the relevant callback\n    library[name].onChange(library[name].state);\n  };\n\n\n  // helper func to get an audio node by type (useAudio always add a type\n  // property to audio nodes, even if they don't normally have them)\n  const getAudioNode = (soundObj, type) => {\n    if (!soundObj.audioNodes) return;\n    return soundObj.audioNodes.filter(n => n.type === type)[0];\n  };\n\n  // public method on soundObjs\n  const fadeIn = function(durationInSeconds, endVol) {\n      if (!library[name].state.isPlaying) library[name].play();\n      fade(endVol ? endVol : 1, durationInSeconds);\n  };\n\n\n  // public method on soundObjs\n  const fadeOut = function (durationInSeconds) {\n      fade(minGain, durationInSeconds);\n  };\n\n\n  // helper func called by fadeIn() and fadeOut()\n  const fade = function (endValue, durationInSeconds) {\n      const gn = getAudioNode(library[name], 'gain');\n      const ct = audioCtx.currentTime;\n      const s = library[name].state;\n      // set the value to transition *from*\n      gn.gain.value = s.volume;\n      if (s.isPlaying) {\n        gn.gain.setValueAtTime(s.volume, ct);\n        // now the values to transition *to*\n        gn.gain.exponentialRampToValueAtTime(endValue, ct + durationInSeconds);\n        s.volume = endValue;\n      }\n  };\n\n\n  // simulate a model of sound reverberation in an acoustic space which\n  // a convolver node can blend with the source sound.\n  function impulseResponse(duration, decay, reverse) {\n    //The length of the buffer.\n    const length = audioCtx.sampleRate * duration;\n    //Create an audio buffer to store the reverb effect.\n    const impulse = audioCtx.createBuffer(2, length, audioCtx.sampleRate);\n    //Use `getChannelData` to initialize empty arrays to store sound data for\n    //the left and right channels.\n    const left  = impulse.getChannelData(0);\n    const right = impulse.getChannelData(1);\n    //Loop through each sample-frame and fill the channel\n    //data with random noise.\n    let n;\n    if (reverse) {\n      //Apply the reverse effect, if `reverse` is `true`.\n      for (let i = 0; i < length; i++) {\n        n = length - i;\n        let multi = Math.pow(1 - n / length, decay)\n        left[n] = (Math.random() * 0.5) * multi;\n        right[n] = (Math.random() * 0.5) * multi;\n      }\n    } else {\n      for (let i = 0; i < length; i++) {\n        n = i;\n        let multi = Math.pow(1 - n / length, decay)\n        left[i] = (Math.random() * 0.5) * multi;\n        right[i] = (Math.random() * 0.5) * multi;\n      }\n    }\n    //Return the `impulse`.\n    return impulse;\n  }\n\n\n  //\n  // MAIN LOOP - parse each sound given in 'sounds' param\n  //\n  Object.entries(sounds).forEach(item => {\n    // work out some info about the sound\n    const hasFilters = typeof item[1] === 'object' && typeof item[1].filters === 'object';\n    name = item[1].name || item[0];\n    src = item[1].src || item[1];\n    filters = hasFilters ? item[1].filters : undefined;\n    // create the sound object for \"item\"\n    library[name] = null;\n    // create an item in cache that will hold a  buffer, in which we will store\n    // the audio data returned from an AJAX request\n    cache[name] = null;\n    // download audio file, save it as a buffer in the fileLoaded() callback,\n    // then add the sound to the library to be returned\n    loadFile(src, item);\n  });\n\n  // attach all our sounds to the given component, if any\n  if (c) c.audio = library;\n\n  // return all the sounds\n  return library;\n};\n\n\n// finally, export the main function\n//\nexport default useAudio;\n"],"names":["sounds","c","document","window","isArr","Array","isArray","noop","ctx","AudioContext","webkitAudioContext","audioCtx","createGain","createGainNode","createDelay","createDelayNode","library","name","src","filters","filterList","cache","totalFiles","Object","keys","length","loadedFiles","fileLoaded","buffer","item","cloneBuffer","addToLibrary","props","cb","forEach","audioObj","settings","state","checkAllFilesLoaded","autoplay","play","dispatchEvent","CustomEvent","detail","inBuffer","outBuffer","createBuffer","numberOfChannels","sampleRate","i","od","getChannelData","id","set","obj","playFrom","pause","fadeIn","fadeOut","rapidFire","stop","mute","unmute","connectTo","onPlay","onPause","onResume","onStop","onChange","input","createBufferSource","output","destination","audioNodes","isPlaying","volume","muted","loop","playbackRate","startTime","startOffset","key","indexOf","isDisabled","createNodes","connectNodes","currentTime","randomiseSound","setupNodesFor","soundObj","s","randomization","r","Math","random","delay","getAudioNode","value","node","setNodeProps","n","graph","filterNodes","allFilters","gain","type","opts","createFilterNode","prop","push","eq","o","undefined","createStereoPanner","createPanner","createBiquadFilter","eqNode","createConvolver","createAnalyser","createDynamicsCompressor","ct","has","setVal","v","setValueAtTime","y","z","abs","setPosition","panValue","frequency","freq","Q","q","duration","decay","reverse","reverb","impulse","left","right","multi","pow","impulseResponse","fftSize","minDecibels","maxDecibels","smoothingTimeConstant","visualiser","threshold","knee","ratio","attack","release","start","noteOn","attachedSounds","snd","curr","next","prev","connect","num","count","dly","loopSetting","setTimeout","time","e","prevVol","otherSound","filter","durationInSeconds","endVol","fade","endValue","gn","exponentialRampToValueAtTime","entries","hasFilters","url","req","XMLHttpRequest","open","responseType","onload","d","response","decodeAudioData","onprogress","percent","lengthComputable","loaded","total","send","loadFile","audio"],"mappings":"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"}