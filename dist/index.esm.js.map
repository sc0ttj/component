{"version":3,"file":"index.esm.js","sources":["../src/component.js","../src/render.js","../src/raf.js","../src/easings.js","../src/tweenState.js","../src/emitter.js","../src/html.js","../src/htmel.js","../src/storage.js","../src/syncTabs.js","../src/useAudio.js","../src/onScroll.js","../src/hooks.js"],"sourcesContent":["// Begin example implementation\n\n// Note:   This is just a demo/experiment\n// Goals:  Super easy to setup, small code base, automatic re-renders on state update\n;(\"use strict\")\n\n// t = target\n// s = source\nconst domDiff = (t, s) => { // from https://codepen.io/tevko/pen/LzXjKE?editors=0010\n  const d = document; // TODO: support shadow DOM - check the root, set accordingly\n  const job = {\n    cfg: {\n      orig: t\n    },\n    // t = target\n    // s = source\n    replace(t, s = t) {\n      const v = d.createElement(\"template\")\n      v.innerHTML = s\n      const vHTML = v.content.firstChild.nextElementSibling\n      if (vHTML.nodeName !== t.nodeName) {\n        t.parentElement.replaceChild(vHTML, t)\n        return\n      }\n      this.loop(t, vHTML)\n    },\n    // tn = target Node\n    // sn = source Node\n    loop(tn, sn, tOrig) {\n      if (tn || sn) {\n        this.checkNew(tn, sn, tOrig)\n        if (\n          tn &&\n          sn &&\n          tn.nodeName !== sn.nodeName\n        ) {\n          this.checkNodeName(tn, sn)\n        } else if (\n          tn &&\n          sn &&\n          tn.nodeName === sn.nodeName\n        ) {\n          this.checkCtx(tn, sn)\n          tn.nodeType !== 3 &&\n            t.nodeType !== 8 &&\n            this.checkAttrs(tn, sn)\n        }\n      }\n      if (tn && sn) {\n        if (tn.childNodes && sn.childNodes) {\n          this.cfg.lengthDiff = [\n            ...t.childNodes,\n            ...sn.childNodes\n          ]\n        } else {\n          this.cfg.lengthDiff = null\n        }\n        Array.apply(null, this.cfg.lengthDiff).forEach(\n          (node, idx) => {\n            this.cfg.lengthDiff &&\n              this.loop(\n                tn.childNodes[idx],\n                sn.childNodes[idx],\n                tn,\n                sn\n              )\n          }\n        )\n      }\n    },\n    checkNodeName(tn, sn) {\n      const n = sn.cloneNode(true)\n      tn.parentElement.replaceChild(n, tn)\n    },\n    checkAttrs(tn, sn) {\n      const attrs = tn.attributes || []\n      const filteredAttrs = Object.keys(attrs).map(n => attrs[n])\n      const attrsNew = sn.attributes || []\n      const filteredAttrsNew = Object.keys(attrsNew).map(\n        n => attrsNew[n]\n      )\n      filteredAttrs.forEach(o => {\n        return sn.getAttribute(o.name) !== null\n          ? tn.setAttribute(o.name, sn.getAttribute(o.name))\n          : tn.removeAttribute(o.name)\n      })\n      filteredAttrsNew.forEach(a => {\n        return (\n          tn.getAttribute(a.name) !== sn.getAttribute(a.name) &&\n          tn.setAttribute(a.name, sn.getAttribute(a.name))\n        )\n      })\n    },\n    checkCtx(tn, sn) {\n      if (tn.nodeValue !== sn.nodeValue) {\n        tn.textContent = sn.textContent\n      }\n    },\n    checkNew(tn, sn, tParent = this.cfg.orig) {\n      if (sn && tn === undefined) {\n        const newNode = sn.cloneNode(true)\n        tParent.nodeType !== 3 &&\n          tParent.nodeType !== 8 &&\n          tParent.appendChild(newNode)\n      } else if (tn && sn === undefined) {\n        tn.parentElement.removeChild(tn)\n      }\n    }\n  }\n  // t = target\n  // s = source\n  Object.create(job).replace(t, s)\n}\n\n\n/**\n * A stateful component creator\n * @constructor\n * @param {object} state - The component state (model).\n */\nfunction Component(state, schema) {\n  const c = function c(state, schema) {\n    c.setState(state, schema)\n    return !state ? c.container : c\n  }\n\n  const C = Component\n  // register the add-ons\n  const validator = C.validator\n  const emitter = C.emitter\n  const tweenState = C.tweenState\n  const springTo = C.springTo\n  const strg = C.storage\n  const useAudio = C.useAudio\n  const onScroll = C.onScroll\n  const onLoop = C.onLoop\n  const devtools = C.devtools\n  const cache = C.memo ? C.memo : function(f){return f;}\n  // used by storage add-on.. maybe try to remove at some point\n  const self = c\n  // re-used a lot..\n  const O = Object\n  const R = RegExp\n\n  // for debouncing render() calls, and window, document\n  let timeout, w, d, raf, t\n\n  c.reactive = true                   // if true, re-render on every state change\n  c.immutable = true                  // if true, freeze the state object after updating it\n  c.debug = devtools ? true : false   //  if true, maintain a history of state changes in `.log`\n  c.scopedCss = true                  // auto prefix component css with a unique id\n  c.state = state                     // component state\n  c.schema = schema                   // component schema (optional)\n\n  // on init, add our initial state to the state history\n  c.log = [{ id: 0, state: state, action: \"init\" }]\n  c.i = c.log.length\n\n  c.view = props => props // the default view (just return the props)\n\n  c.middleware = []\n\n  // a unique ID, used for scoping component CSS and by devtools to register them\n  c.uid = Math.random()\n    .toString(36)\n    .split(\".\")[1]\n\n  c.isNode =\n    typeof process !== \"undefined\" &&\n    process !== null &&\n    process.versions !== null &&\n    process.versions.node !== null\n\n  if (!c.isNode) {\n    w = window\n    d = document  // TODO: support shadow DOM - check the root, set accordingly\n    raf = requestAnimationFrame\n    // the <style> elem into which we put our component CSS\n    // TODO: only do this if component styles are defined\n    c.css = d.createElement(\"style\")\n    c.css.id = c.uid\n    d.head.appendChild(c.css)\n  }\n\n  /**\n   * Define chainable named \"actions\" that will update our\n   * state in specific ways and register in our state history\n   */\n  c.actions = actions => {\n    c.actionsList = actions\n    // convert each key/value to set state function:\n    O.keys(actions).forEach(axn => {\n      if (typeof c[axn] !== \"undefined\") return false\n      // add the action as a function\n      c[axn] = newState => {\n        // set current action\n        c.action = axn\n        // run action\n        actions[axn](newState)\n        // make sure the component returns itself, so it's always chainable\n        return c\n      }\n    })\n    return c\n  }\n\n  /**\n   * Used to freeze the component state\n   * @param {object} o - the object to freeze\n   */\n  c.freeze = cache(o => {\n    if (!O.isFrozen(o)) {\n      // Recursively call until all child objects are frozen\n      O.keys(o).forEach(k => c.freeze(o[k]))\n      O.freeze(o)\n    }\n    return o\n  })\n\n  /**\n   * Used to compare the current and next component state\n   * @param {object} x - the object to compare with y\n   * @param {object} y - the object to compare with x\n   */\n  c.eq = cache((x, y) => {\n    const ok = O.keys,\n      tx = typeof x,\n      ty = typeof y\n    return x && y && tx === \"object\" && tx === ty\n      ? ok(x).length === ok(y).length &&\n          ok(x).every(key => c.eq(x[key], y[key]))\n      : String(x) === String(y)\n  })\n\n  /**\n   * Set the component state\n   * @param {object} newState - the new state to update to\n   */\n  c.setState = newState => {\n    const nextState = { ...c.state, ...newState };\n    // get initial state from localStorage, if it's in there\n    if (strg && !c.done) {\n      const pState = strg.getItem(c, nextState);\n      if (pState) newState = { ...newState, ...pState };\n    }\n    c.done = true;\n\n    // enable schema validation using @scottjarvis/validator\n    if (validator && c.schema) {\n      const err = cache(validator(nextState, c.schema))\n      const msg = \"State doesn't match schema:\"\n      if (err.length > 0) {\n        console.error(msg, \"\\n\", err, \"\\n\")\n        throw new Error(msg + \"\\n\" + JSON.stringify(err) + \"\\n\")\n      }\n    }\n    // ...the new state is valid, lets continue\n\n    // update previous and current state\n    c.prev = c.state\n    c.state = { ...c.state, ...nextState }\n\n    if (!c.eq(c.state, c.prev)) {\n\n      if (strg && c.done) {\n        // c.store is just the name of the key in localStorage,\n        // where we keep our JSON stringified state\n        strg.setItem(c, c.state)\n      }\n\n      // re-render component\n      if (c.reactive) c.render(c.container, c.ctx)\n\n      if (t && !c.isNode) cancelAnimationFrame(t)\n\n      // c.tt = component is \"time travelling\" (traversing state history)\n      if (c.debug && c.tt !== true) {\n        // if node, just use setTimeout\n        if (c.isNode) raf = (logFn) => setTimeout(() => logFn(), 1)\n        t = raf(() => {\n          // we are not traversing state history, so add the new state to the log\n          c.log.push({\n            id: c.log.length,\n            state: c.state,\n            action: c.action || \"setState\"\n          })\n          // move along index\n          c.i = c.log.length -1\n        })\n      }\n\n      // log state changes if debug = true\n      //if (c.debug) console.log(c.i, [c.state, ...c.log])\n\n      // freeze state so it can only be changed through setState()\n      if (c.immutable) c.freeze(c.state)\n\n      // if we updated using an \"action\" method, and emitter is avail,\n      // then emit an event with same name as the \"action\" called,\n      // passing in the current state\n      if (typeof emitter !== \"undefined\" && !!c.action) {\n        emitter.emit(`${c.action}`, { ...c.state })\n      }\n\n      // run any middlware functions that were defined by the user\n      c.middleware.forEach(fn => fn({ ...c.state }))\n\n      c.action = undefined\n\n      return c\n    }\n  }\n\n  /**\n   * Tween from the current state to the given state, then set the given\n   * state as the new state.\n   *\n   * @param {object} cfg - the settings used for the tweening\n   *\n   */\n  c.tweenState = (props, cfg) => {\n    typeof tweenState !== \"undefined\"\n      ? tweenState(c, props, cfg)\n      : c(props)\n    return c\n  }\n\n  /**\n   * Animate from the current state to the given state, then set the given\n   * state as the new state. Uses spring-based physics.\n   *\n   * @param {object} cfg - the settings used for the spring\n   *\n   */\n  c.springTo = (props, cfg) => {\n    typeof springTo !== \"undefined\"\n      ? springTo(c, props, cfg)\n      : c(props)\n    return c\n  }\n\n  /**\n   * Audio for components\n   *\n   * @param {object} audio library - the audio files and their settings\n   *\n   */\n  c.useAudio = (props) => {\n    if (typeof useAudio !== \"undefined\") {\n      useAudio(props, c)\n    } else {\n      c(props)\n    }\n    return c\n  }\n\n  /**\n   * Scroll-based animations for components\n   *\n   * @param {object}\n   *\n   */\n  c.onScroll = fn => {\n    if (onScroll) {\n      onScroll(fn, c);\n    }\n    return c\n  }\n\n  /**\n   * Game loop (fixed interval loop, variable interval rendering)\n   *\n   * @param {object}\n   *\n   */\n  if (onLoop) {\n    c.onLoop = (fn, o) => {\n      const opts = {\n        minFps: 15,\n        targetFps: 60,\n        maxRestarts: Infinity,\n        runTime: Infinity,\n        forceSetTimeout: false,\n        autoResume: true,\n        // override the options above with any passed into the component\n        ...o,\n      }\n      // create a controllable loop, if needed\n      c.loop = c.loop ? c.loop : new onLoop({ ...c.state, ...opts }, fn, c)\n      // attach the methods to control the loop\n      c.start = () => c.loop.start();\n      c.stop = () => c.loop.stop();\n      c.pause = () => c.loop.pause();\n      c.resume = () => c.loop.resume();\n    }\n  }\n\n  c.on = (ev, fn) => {\n    typeof emitter !== \"undefined\"\n      ? emitter.on(ev, fn)\n      : false\n    return c\n  }\n\n  c.once = (ev, fn) => {\n    if (typeof emitter !== \"undefined\") {\n      emitter.on(ev, props => {\n        fn(props)\n        emitter.off(ev, fn)\n      })\n    }\n    return c\n  }\n\n  c.off = (ev, fn) => {\n    typeof emitter !== \"undefined\"\n      ? emitter.off(ev, fn)\n      : false\n    return c\n  }\n\n  /**\n   * Travel forward/backward to different states in the state history\n   * @param {number} num - the number of steps through the history to take\n   * @param {string} direction - 'f' for forward, 'b' for backwards\n   */\n  c.go = function(num, dir) {\n    let i\n    if (dir === \"f\") {\n      i = c.i + num\n    } else {\n      i = c.i - num\n    }\n    if (c.log[i]) {\n      c.i = i\n      c.tt = true;\n      c(c.log[i].state) // set state\n      c.tt = false;\n    }\n    return c\n  }\n\n  /**\n   * Go to previous (or first) state in the state history\n   * @param {number} num - the number of steps through the history to take, 0 if 'num' not given\n   */\n  c.rw = function(num) {\n    if (!num) {\n      if (c.log[0]) {\n        c.tt = true;\n        c(c.log[0].state) // set state\n        c.tt = false;\n      }\n      c.i = 0\n      return c\n    }\n    return c.go(num, \"b\")\n  }\n\n  /**\n   * Go to more recent state in the state history\n   * @param {number} num - the number of steps through the history to take, most recent if 'num' not given\n   */\n  c.ff = function(num) {\n    if (!num) {\n      if (c.log[c.log.length - 1]) {\n        c.tt = true;\n        c(c.log[c.log.length - 1].state) // set state\n        c.tt = false;\n      }\n      c.i = c.log.length -1\n      return c\n    }\n    return c.go(num, \"f\")\n  }\n\n  /**\n   * If in browser, puts scoped component styles in c.css\n   */\n  c.setCss = function() {\n    // if in browser\n    if (c && !c.isNode) {\n      // if a style is defined\n      if (c.css && typeof c.style === \"function\") {\n        // get the latest component style\n        let st = c.style(c.state) // the css\n\n        // auto-prefix CSS styles with a unique id,to \"scope\" the\n        // styles to the component only\n        if (c.scopedCss) {\n          const p = c.container.id ? \"#\" : \".\"\n          // get container id, or class if no id\n          let u = c.container.id ? c.container.id : c.container.className\n          // if container has no class or id, use uid\n          u = !!u ? u : c.uid\n\n          // ..these 3 are used for scoping CSS, in setCss()\n          const fx1 = new R(u + \" ,\\\\s*\\\\.\", \"gm\")\n          const fx2 = new R(u + \" ,\\\\s*#\", \"gm\")\n          const fx3 = new R(u + \" ,\\\\s*([a-z\\\\.#])\", \"gmi\")\n          // func to scope css\n          const fx = (v,p,u) =>\n            v.replace(/}/g, \"}\\n\")\n             .replace(/\\;\\s*\\n/g, \";\")\n             .replace(/{\\s*\\n/g, \"{ \")\n             .replace(/^\\s+|\\s+$/gm, \"\\n\")\n             .replace(/(^[\\.#\\w][\\w\\-]*|\\s*,[\\.#\\w][\\w\\-]*)/gm, p + u + \" $1\")\n             .replace(fx1, \", \" + p + u + \" \")\n             .replace(fx2, \", \" + p + u + \" #\")\n             .replace(fx3, \", \" + p + u + \" $1\")\n             .replace(/\\n/g, \"\")\n             .replace(/\\s\\s+/g, \" \")\n           // scope the css\n           st = cache(fx(st,p,u))\n        }\n\n        // minify the CSS\n        const minCss = st.replace(/\\n/g, \"\").replace(/\\s\\s+/g, \" \")\n        // if the new CSS is changed from previous, re-render it\n        if (c.css.innerHTML !== minCss) c.css.innerHTML = minCss\n      }\n    }\n  }\n\n  // used by .toString()\n  const toStr = (view, style) => {\n    let s = '';\n    if (view.outerHTML) {\n      if (style) s = `<style>${style}\\n</style>\\n`\n      s += `${view.outerHTML}`.replace(/^ {4}/gm, \"\")\n    } else if (typeof view === \"string\") {\n      try {\n        // if view is a JSON string\n        s = JSON.parse(view)\n        // return the view as prettified JSON\n        s = JSON.stringify(s, null, 2)\n      } catch (err) {\n        if (style) s = `<style>${style}\\n</style>\\n`\n        s += `${view}`.replace(/^ {4}/gm, \"\")\n      }\n    } else if (typeof view === \"object\" || Array.isArray(view)) {\n      // return the view as prettified JSON\n      s = JSON.stringify(view, null, 2)\n    }\n    //if (c.debug) console.log(s)\n    return s\n  }\n\n  /*\n  * Render the current view as a string, including\n  * our component styling, in a <style> tag\n  */\n  c.toString = function() {\n    let view = c.view(c.state, c.ctx)\n    let str = ''\n    let style = ''\n\n    // get local state\n    if (!c.done && strg) {\n      const pState = strg.getItem(c, c.state);\n      c(pState);\n      view = typeof c.view === \"function\" ? c.view(pState, c.ctx) : view\n    }\n\n    // get component styles, nicely indented\n    if (typeof c.style === \"function\") {\n      style = c.style(c.state).replace(/^ {4}/gm, \"\")\n    }\n\n    return cache(toStr(view,style))\n  }\n\n  /**\n   * Re-render the component and add it to the page\n   * @param {string|element} container - the element which holds the component\n   */\n  c.render = function(el, ctxType) {\n    if (c.isNode) return c.toString()\n\n    let view;\n\n    // get state from localStorage, if it's in there\n    if (!c.html && strg) {\n      const pState = strg.getItem(c, c.state);\n      view = typeof c.view === \"function\" ? c.view(pState, c.ctx) : null\n      c(pState); // set state\n    }\n\n    // make sure we have container as an HTML Element\n    if (d && !c.html) {\n      // TODO: support shadow DOM - check the root , set `d` accordingly\n      el = d.querySelector(el)\n    }\n    c.html = c.container = el\n\n    // get the canvas context, if needed\n    if (c.html && c.html.getContext) {\n      c.ctx = c.ctx ? c.ctx : c.html.getContext(ctxType ? ctxType : '2d')\n    }\n\n    if (timeout) cancelAnimationFrame(timeout)\n\n    timeout = raf(() => {\n      if (c.css && c.style) c.setCss()\n\n      // if we a container, lets (re)render the view (if any) to the page\n      if (c.html) {\n        view = typeof c.view === \"function\" ? c.view(c.state, c.ctx) : null\n        // if container exists, is *not* a canvas\n        if (!c.ctx) {\n          // get the view\n          // try to update view:\n          // try DOM diffing, else append to empty innerHTML, else replace innerHTML\n          try {\n            domDiff(c.html.firstElementChild, view.outerHTML ? view.outerHTML : view)\n            //console.log('diffed')\n          } catch (err) {\n            if (view && view.outerHTML) {\n              c.html.innerHTML = ''\n              c.html.append(view)\n              //console.log('cleared & appended')\n            } else {\n              c.html.innerHTML = view\n              //console.log('replaced innerHTML')\n            }\n          }\n        } else {\n          // else if container exists and *is* a canvas\n          c.view(c.state, c.ctx)\n        }\n      }\n      // for devtools\n      if (devtools && c.html) {\n        c.html.firstChild.setAttribute('data-uid', c.uid)\n        devtools.populateUI(c.html)\n      }\n    })\n\n    // return the container element\n    return c.html\n  }\n\n  // for devtools\n  if (!c.isNode) {\n    w.sjComponents = w.sjComponents || {};\n    w.sjComponents[c.uid] = c;\n  }\n\n  return c\n}\n\nexport default Component\n",";(\"use strict\")\n\n// t = target\n// s = source\nconst domDiff = (t, s) => { // from https://codepen.io/tevko/pen/LzXjKE?editors=0010\n  const job = {\n    cfg: {\n      orig: t\n    },\n    // t = target\n    // s = source\n    replace(t, s = t) {\n      const v = document.createElement(\"template\")\n      v.innerHTML = s\n      const vHTML = v.content.firstElementChild\n      if (vHTML.nodeName !== t.nodeName) {\n        t.parentElement.replaceChild(vHTML, t)\n        return\n      }\n      this.loop(t, vHTML)\n    },\n    // tn = target Node\n    // sn = source Node\n    loop(tn, sn, tOrig) {\n      if (tn || sn) {\n        this.checkNew(tn, sn, tOrig)\n        if (\n          tn &&\n          sn &&\n          tn.nodeName !== sn.nodeName\n        ) {\n          this.checkNodeName(tn, sn)\n        } else if (\n          tn &&\n          sn &&\n          tn.nodeName === sn.nodeName\n        ) {\n          this.checkCtx(tn, sn)\n          tn.nodeType !== 3 &&\n            t.nodeType !== 8 &&\n            this.checkAttrs(tn, sn)\n        }\n      }\n      if (tn && sn) {\n        if (tn.childNodes && sn.childNodes) {\n          this.cfg.lengthDiff = [\n            ...t.childNodes,\n            ...sn.childNodes\n          ]\n        } else {\n          this.cfg.lengthDiff = null\n        }\n        Array.apply(null, this.cfg.lengthDiff).forEach(\n          (node, idx) => {\n            this.cfg.lengthDiff &&\n              this.loop(\n                tn.childNodes[idx],\n                sn.childNodes[idx],\n                tn,\n                sn\n              )\n          }\n        )\n      }\n    },\n    checkNodeName(tn, sn) {\n      const n = sn.cloneNode(true)\n      tn.parentElement.replaceChild(n, tn)\n    },\n    checkAttrs(tn, sn) {\n      const attrs = tn.attributes || []\n      const filteredAttrs = Object.keys(attrs).map(n => attrs[n])\n      const attrsNew = sn.attributes || []\n      const filteredAttrsNew = Object.keys(attrsNew).map(\n        n => attrsNew[n]\n      )\n      filteredAttrs.forEach(o => {\n        return sn.getAttribute(o.name) !== null\n          ? tn.setAttribute(o.name, sn.getAttribute(o.name))\n          : tn.removeAttribute(o.name)\n      })\n      filteredAttrsNew.forEach(a => {\n        return (\n          tn.getAttribute(a.name) !== sn.getAttribute(a.name) &&\n          tn.setAttribute(a.name, sn.getAttribute(a.name))\n        )\n      })\n    },\n    checkCtx(tn, sn) {\n      if (tn.nodeValue !== sn.nodeValue) {\n        tn.textContent = sn.textContent\n      }\n    },\n    checkNew(tn, sn, tParent = this.cfg.orig) {\n      if (sn && tn === undefined) {\n        const newNode = sn.cloneNode(true)\n        tParent.nodeType !== 3 &&\n          tParent.nodeType !== 8 &&\n          tParent.appendChild(newNode)\n      } else if (tn && sn === undefined) {\n        tn.parentElement.removeChild(tn)\n      }\n    }\n  }\n  // t = target\n  // s = source\n  Object.create(job).replace(t, s)\n}\n\nlet timeout;\n\nconst render = (view, sel) => {\n  if (!window) return v\n\n  const v = typeof view === 'function' ? view() : view\n  const c = document.querySelector(sel)\n\n  if (timeout) cancelAnimationFrame(timeout)\n\n  timeout = requestAnimationFrame(() => {\n    if (c && c.nodeName && v) {\n      domDiff(\n        c,\n        v.outerHTML ? v.outerHTML : `<${c.nodeName} ${c.id ? `id=\"${c.id}\"` : ''} ${c.className ? `class=\"${c.className}\"` : ''}>${v}</${c.nodeName}>`\n      )\n      //console.log('diffed DOM')\n    }\n  });\n\n  return c\n}\n\nexport default render;\n","var performance =\n  typeof process !== \"undefined\" && typeof require !== \"undefined\"\n    ? require(\"perf_hooks\").performance\n    : window.performance\n\nvar now = performance.now,\n  root = typeof window === \"undefined\" ? global : window,\n  vendors = [\"moz\", \"webkit\"],\n  suffix = \"AnimationFrame\",\n  raf = root[\"request\" + suffix],\n  caf = root[\"cancel\" + suffix] || root[\"cancelRequest\" + suffix]\n\nfor (var i = 0; !raf && i < vendors.length; i++) {\n  raf = root[vendors[i] + \"Request\" + suffix]\n  caf =\n    root[vendors[i] + \"Cancel\" + suffix] ||\n    root[vendors[i] + \"CancelRequest\" + suffix]\n}\n\n// Some versions of FF have rAF but not cAF\nif (!raf || !caf) {\n  var last = 0,\n    id = 0,\n    queue = [],\n    frameDuration = 1000 / 60\n\n  raf = function(callback) {\n    if (queue.length === 0) {\n      var _now = now(),\n        next = Math.max(0, frameDuration - (_now - last))\n      last = next + _now\n      setTimeout(function() {\n        var cp = queue.slice(0)\n        // Clear queue here to prevent\n        // callbacks from appending listeners\n        // to the current frame's queue\n        queue.length = 0\n        for (var i = 0; i < cp.length; i++) {\n          if (!cp[i].cancelled) {\n            try {\n              cp[i].callback(last)\n            } catch (e) {\n              setTimeout(function() {\n                throw e\n              }, 0)\n            }\n          }\n        }\n      }, Math.round(next))\n    }\n    queue.push({\n      handle: ++id,\n      callback: callback,\n      cancelled: false\n    })\n    return id\n  }\n\n  caf = function(handle) {\n    for (var i = 0; i < queue.length; i++) {\n      if (queue[i].handle === handle) {\n        queue[i].cancelled = true\n      }\n    }\n  }\n}\n\nif (typeof module !== \"undefined\") {\n  module.exports.raf = function(fn) {\n    // Wrap in a new function to prevent\n    // `cancel` potentially being assigned\n    // to the native rAF function\n    return raf.call(root, fn)\n  }\n  module.exports.cancel = function() {\n    caf.apply(root, arguments)\n  }\n  module.exports.polyfill = function(object) {\n    if (!object) {\n      object = root\n    }\n    object.requestAnimationFrame = raf\n    object.cancelAnimationFrame = caf\n  }\n}\n\nexport default function(fn) {\n  // Wrap in a new function to prevent\n  // `cancel` potentially being assigned\n  // to the native rAF function\n  return raf.call(root, fn)\n}\n","const easing = {\n  // no easing, no acceleration\n  linear: t => t,\n  // accelerating from zero velocity\n  inQuad: t => t * t,\n  // decelerating to zero velocity\n  outQuad: t => t * (2 - t),\n  // acceleration until halfway, then deceleration\n  inOutQuad: t => (t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t),\n  // accelerating from zero velocity\n  inCubic: t => t * t * t,\n  // decelerating to zero velocity\n  outCubic: t => --t * t * t + 1,\n  // acceleration until halfway, then deceleration\n  inOutCubic: t =>\n    t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,\n  // accelerating from zero velocity\n  inQuart: t => t * t * t * t,\n  // decelerating to zero velocity\n  outQuart: t => 1 - --t * t * t * t,\n  // acceleration until halfway, then deceleration\n  inOutQuart: t => (t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t),\n  // accelerating from zero velocity\n  inQuint: t => t * t * t * t * t,\n  // decelerating to zero velocity\n  outQuint: t => 1 + --t * t * t * t * t,\n  // acceleration until halfway, then deceleration\n  inOutQuint: t =>\n    t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t,\n  // elastic bounce effect at the beginning\n  inElastic: t => (0.04 - 0.04 / t) * Math.sin(25 * t) + 1,\n  // elastic bounce effect at the end\n  outElastic: t => ((0.04 * t) / --t) * Math.sin(25 * t),\n  // elastic bounce effect at the beginning and end\n  inOutElastic: t =>\n    (t -= 0.5) < 0\n      ? (0.02 + 0.01 / t) * Math.sin(50 * t)\n      : (0.02 - 0.01 / t) * Math.sin(50 * t) + 1,\n  // slight acceleration from zero to full speed\n  inSin: t => 1 + Math.sin((Math.PI / 2) * t - Math.PI / 2),\n  // slight deceleration at the end\n  outSin: t => Math.sin((Math.PI / 2) * t),\n  // slight acceleration at beginning and slight deceleration at end\n  inOutSin: t => (1 + Math.sin(Math.PI * t - Math.PI / 2)) / 2,\n  // Accelerate exponentially until finish\n  inExpo: t => {\n    if (t === 0) return 0\n    return Math.pow(2, 10 * (t - 1))\n  },\n  //\n  // Initial exponential acceleration slowing to stop\n  outExpo: function(t) {\n    if (t === 1) return 1\n    return -Math.pow(2, -10 * t) + 1\n  },\n  // Exponential acceleration and deceleration\n  inOutExpo: function(t) {\n    if (t === 0 || t === 1) return t\n    var scaledTime = t * 2\n    var scaledTime1 = scaledTime - 1\n    if (scaledTime < 1) return 0.5 * Math.pow(2, 10 * scaledTime1)\n    return 0.5 * (-Math.pow(2, -10 * scaledTime1) + 2)\n  },\n  // Slow movement backwards then fast snap to finish\n  inBack: function(t, magnitude) {\n    var m = typeof magnitude !== \"undefined\" ? magnitude : 1.70158\n    return t * t * ((m + 1) * t - m)\n  },\n  // Fast snap to backwards point then slow resolve to finish\n  outBack: function(t, magnitude) {\n    var m = typeof magnitude !== \"undefined\" ? magnitude : 1.70158\n    var scaledTime = t / 1 - 1\n    return scaledTime * scaledTime * ((m + 1) * scaledTime + m) + 1\n  },\n  // Slow movement backwards, fast snap to past finish, slow resolve to finish\n  inOutBack: function(t, magnitude = 1.70158) {\n    var scaledTime = t * 2\n    var scaledTime2 = scaledTime - 2\n    var s = magnitude * 1.525\n    if (scaledTime < 1)\n      return 0.5 * scaledTime * scaledTime * ((s + 1) * scaledTime - s)\n    return 0.5 * (scaledTime2 * scaledTime2 * ((s + 1) * scaledTime2 + s) + 2)\n  }\n}\n\nexport default easing\n","import raf from './raf.js'\nimport easing from \"./easings.js\"\n;(\"use strict\")\n\n\n// if no window.performance, use 'perf_hooks' module\n// (from https://stackoverflow.com/questions/23003252/window-performance-now-equivalent-in-nodejs)\nvar performance =\n  typeof process !== \"undefined\" && typeof require !== \"undefined\"\n    ? require(\"perf_hooks\").performance\n    : window.performance\n\n// if no requestAnimationFrame, use the 'raf' polyfill\nvar requestAnimationFrame =\n  typeof window !== \"undefined\" &&\n  typeof window.requestAnimationFrame !== \"undefined\"\n    ? window.requestAnimationFrame\n    : raf\n\n//\n//\n// ES5-loose (transpiled) version of\n// https://github.com/jeremenichelli/phena/blob/master/src/index.js\n//\n\nvar noop = function noop() {}\n\nvar now = function now() {\n  return performance && performance.now ? performance.now() : Date.now()\n}\n\nvar step = function step(context) {\n  var delay = context.delay,\n    from = context.from,\n    to = context.to,\n    duration = context.duration,\n    startTime = context.startTime,\n    easeFn = context.ease,\n    onUpdate = context.onUpdate,\n    onComplete = context.onComplete\n\n  var currentTime = now()\n  var elapsed = currentTime - startTime\n\n  if (delay >= elapsed) {\n    context.frame =\n      requestAnimationFrame(function() {\n        return step(context)\n      }) + 1\n    return\n  }\n\n  // calculate progress according to time and and easing\n  var progress = Math.min(1, (elapsed - delay) / duration)\n\n  // add progress to tween props\n  context.progress = progress\n\n  var values = from.length\n    ? from.map(function(val, index) {\n        var value = val + (to[index] - val) * easeFn(progress)\n        if (Number.isNaN(value)) {\n          value = val + (to[index] - val) * progress\n        }\n        return value\n      })\n    : (() => {\n        var value = from + (to - from) * easeFn(progress)\n        if (Number.isNaN(value)) {\n          value = from + (to - from) * progress\n        }\n        return value\n      })()\n\n  // EDIT by @sc0ttj - pass in the whole context, with values\n  onUpdate({ ...context, values }) // call complete callback or invoke new frame\n\n  // EDIT by @sc0ttj - pass in the whole context, with values\n  if (progress === 1) onComplete({ ...context, values })\n  else\n    context.frame =\n      requestAnimationFrame(function() {\n        return step(context)\n      }) + 1\n}\n\nvar Tween = /*#__PURE__*/ (function() {\n  function Tween(context) {\n    this._c = context\n    this._c.ease = easing[context.ease] || easing[ease]\n    this._c.onUpdate = context.onUpdate || noop\n    this._c.onComplete = context.onComplete || noop\n    this._c.delay = context.delay || 0\n    this._c.duration = context.duration || 200\n    if (!context.paused) this.start()\n  }\n\n  var _proto = Tween.prototype\n\n  _proto.start = function start() {\n    this._c.startTime = now()\n    step(this._c)\n  }\n\n  _proto.cancel = function cancel() {\n    cancelAnimationFrame(this._c.frame)\n  }\n\n  return Tween\n})()\n\n\n// for each property in newState, get the value from the given state\nconst getStateToTween = function(state, newState) {\n  const stateToTween = {}\n  Object.entries(state).forEach(entry => {\n    const key = entry[0];\n    const val = entry[1];\n    if (newState[key]) stateToTween[key] = val;\n  })\n  return stateToTween\n}\n\n// go through properties in the given state, add to the given array\nconst addValues = function(state, array) {\n  Object.keys(state).forEach((key, index) => {\n    if (typeof state[key] !== \"undefined\") {\n      if (typeof state[key] !== \"object\") {\n        array.push(state[key])\n        return\n      }\n      addValues(state[key], array)\n    }\n  })\n}\n\nconst setTweenedValues = function(state, vals) {\n  function reducer(obj, [key, val]) {\n    obj[key] = val\n    if (typeof val === \"number\") {\n      obj[key] = vals.shift()\n    } else if (typeof val === \"object\") {\n      obj[key] = Object.entries(val).reduce(reducer, {})\n    }\n    return obj\n  }\n  const tweenedState = Object.entries(state).reduce(reducer, {})\n  return tweenedState\n}\n\nconst tweenState = (self, newState, cfg) => {\n  // define default callbacks\n  var onStart = cfg.onStart ? cfg.onStart : noop\n  var onUpdate = cfg.onUpdate ? cfg.onUpdate : noop\n  var onComplete = cfg.onComplete ? cfg.onComplete : noop\n  var shouldSetState = cfg.shouldSetState ? cfg.shouldSetState : true\n  var onSetState = cfg.onSetState ? cfg.onSetState : noop\n\n  if (typeof shouldSetState === \"boolean\") shouldSetState = () => shouldSetState\n\n  cfg.frame = 1\n  cfg.frameTotal = Math.ceil((60 / 1000) * (cfg.delay + cfg.duration)) + 2\n\n  // get a state matching the shape of newState, but with values from self.state\n  var stateToTween = getStateToTween(self.state, newState)\n\n  var startValuesArr = []\n  var endValuesArr = []\n  // use current state values as start values\n  addValues(stateToTween, startValuesArr)\n  // use next state values as end values\n  addValues(newState, endValuesArr)\n\n  // execute the tween, set state on completion\n  var tween = new Tween({\n    from: startValuesArr || 0,\n    to: endValuesArr || 1,\n    paused: cfg.paused || false,\n    delay: cfg.delay || 0,\n    duration: cfg.duration || 200,\n    ease: cfg.ease || \"linear\",\n    frame: 1,\n    frameTotal: cfg.frameTotal || 1,\n    onUpdate: props => {\n      // make sure values is an array\n      var tweenedState = setTweenedValues(newState, [...props.values])\n      if (props.frame === 1) onStart(props)\n      // set current tween properties as the new state\n      if (shouldSetState(props)) {\n        self.setState(tweenedState)\n        onSetState(props)\n      }\n      return onUpdate({ ...props, tweenedState })\n    },\n    onComplete: props => {\n      self.setState(newState)\n      return onComplete(props)\n    }\n  })\n\n  return tween\n}\n\nexport default tweenState\n","// from https://raw.githubusercontent.com/jeromeetienne/microevent.js/master/microevent.js\n\n// This is basically \"MicroEvent\", renamed to \"emitter\", with\n// some changes:\n//  - use \"on\", \"off\", \"emit\", instead of \"bind\", \"unbind\", \"trigger\"\n\n// @TODO\n//  1. update \"on\" and \"off\" methods:\n//    - support matching events via regex pattern:\n//    - \"on\":  for all matches, add fn to this._evts[match]\n//    - \"off\": for all matches, rm fn from this._evts[match]\n//  2. allow to pass data/props around in \"emit\" and \"on\"\n\n;(\"use strict\")\n\nconst emitter = {\n  on: function(ev, fn) {\n    this._evs = this._evs || {}\n    this._evs[ev] = this._evs[ev] || []\n    this._evs[ev].push(fn)\n  },\n  off: function(ev, fn) {\n    this._evs = this._evs || {}\n    if (ev in this._evs === false) return false\n    this._evs[ev].splice(this._evs[ev].indexOf(fn), 1)\n  },\n  emit: function(ev /* , args... */) {\n    this._evs = this._evs || {}\n    if (ev in this._evs === false) return false\n    for (var i = 0; i < this._evs[ev].length; i++) {\n      // the \"arguments\" variable holds the current state (see src/component.js:214)\n      this._evs[ev][i].apply(this, Array.prototype.slice.call(arguments, 1))\n    }\n  }\n}\n\nexport default emitter\n","/*\n * html`<div>...</div>`\n * - allows a cleaner, more powerful way to create HTML using JS Template literals:\n *   - auto joins arrays, without adding commas (so no need to keep using .join('') in your templates)\n *   - supports embedding real DOM nodes: Node Lists, HTML Collections, HTML Objects, Elements\n *   - supports embedding JS Objects as HTML attributes, CSS styles, and HTML data attributes:\n *     - `html` works out the context and converts the given object to an appropriate string\n *     - `html` ignores/strips nested child objects when converting to string\n *   - hides falsey stuff (instead of printing \"false\" [etc] in the output)\n *   - returns generated HTML as a string\n *\n * @param {Template Literal} representing a single HTML element\n * @return {String}\n */\n\nconst html = (strings, ...vals) => {\n  // create a property in which to save event attribute funcs, which we'll\n  // later attach to their elements as proper event listeners\n  html.funcs = html.funcs || [];\n  // start: loop over the template content\n  var output = strings.map((str, i) => {\n    html.i = html.i || i;\n    var v = vals[i] || '';\n    // dont ignore zeros\n    if (typeof vals[i] === 'number') v = vals[i]\n    var ctx = 'attr'\n    // workout our current \"context\" (either inside an HTML opening tag,\n    // inside a style attribute, or inside a data-* attribute)\n    if (str.match(/style=(\"|')$/i)) { //\"\n      ctx = 'style'\n    }\n    // check if dealing with a html `data-*` attribute\n    else if (str.match(/data-[a-z0-9\\-_]+=(\"|')$/i)) { //\"\n      ctx = 'dataAttr'\n    }\n\n    // check for a nested component\n    else if (typeof v === 'function' && v.uid && v.state && v.setState && v.render) {\n      ctx = 'nestedComponent'\n    }\n    // check for event attributes like `onclick=\"{someFunc}\"` etc\n    else if (typeof v === 'function'\n        && ctx === 'attr'\n        && str.match(/ on[a-z0-9]+=(\"|')$/i)) //\"\n    {\n      ctx = 'funcAttr'\n    }\n\n\n    // check for either an Element, HTML Collection, Node List, String,\n    // Object, etc):\n    // if current value to process (v) is an HTML Object of any kind,\n    // gets its outer HTML and use that\n    if (v.nodeName && ctx === 'attr') {\n      v = v.outerHTML;\n\n    } else if (ctx === 'nestedComponent' && typeof v === 'function') {\n\n      // *Important* ..We have a nested component, with its own state and\n      // render loop, but without a container.. We don't need or want it to\n      // setState and re-render, we just want it's latest \"view\", which is\n      // also much faster to get than doing a whole setState + re-render\n      str += v.view(v.state)\n      v=''\n\n    } else if (ctx === 'funcAttr' && typeof v === 'function' && !v.uid) {\n      // keep the function for later, but dont include it in output\n      if (Array.isArray(html.funcs)) html.funcs[html.i] = v;\n      // replace `onclick=\"...\" with onclick=\"${i}\" - we'll reference\n      // it later, once it's a real Element, so we can attach funcs[i] to\n      // it, as a proper event listener method\n      v='';\n      str += html.i\n    } else if (Array.isArray(v)) {\n      // if we have a Node List or HTML Collection, convert its\n      // items to strings\n      if (v[0].nodeName) v = v.map(n => `${n.outerHTML}`)\n      // now concat the array itself to string\n      v = v.join('');\n\n    } else if (typeof v === \"object\") {\n      var s = ''; // the string to build from our object (if needed)\n      if (ctx === 'dataAttr') {\n        // if object is for a data attr, add it as JSON\n        s += JSON.stringify(v).trim();\n      } else {\n        // gets the objects properties as strings,\n        // while ignoring nested objects, arrays etc\n        for (var p in v) {\n          if (p && v && v.hasOwnProperty(p) && typeof v[p] !== \"object\") {\n            // if inside a style attr, return `key: val;`\n            // if inside an HTML tag, return ` key=\"val\"`\n            if (ctx === 'style') s += `${p}:${v[p]};`;\n            if (ctx === 'attr')  s += ` ${p}=\"${v[p]}\"`;\n          }\n        }\n      }\n      // now we've built the appropriate string, set it as the value to\n      // add to our template\n      v = s\n    }\n    // fix not returning zeros (JS treats them as \"falsey\")\n    if (vals[i] === 0) v = \"0\"\n    // now we've converted `v` to a string version of whatever is was,\n    // we can return the current string, with `v` appended, and then\n    // move to next iteration\n\n    html.i += 1;\n    return str ? str + (v || '') : '';\n  }).join('');\n\n  // return the compiled HTML as a string\n  return output;\n}\n\nexport default html\n","import html from './html'\n\n/**\n * htmel`<div>...</div>`\n * - allows a cleaner, more powerful way to create HTML using JS Template literals:\n *   - auto joins arrays, without adding commas (so no need to keep using .join('') in your templates)\n *   - supports embedding real DOM nodes: Node Lists, HTML Collections, HTML Objects, Elements\n *   - supports embedding JS Objects as HTML attributes, CSS styles, and HTML data attributes:\n *     - `html` works out the context and converts the given object to an appropriate string\n *     - `html` ignores/strips nested child objects when converting to string\n *   - supports embedding functions in event attributes:\n *     - `htmel` will attach them as callbacks to the relevant Event Listeners\n *   - hides falsey stuff (instead of printing \"false\" [etc] in the output)\n *   - returns the generated HTML as an HTML Object (browser) or a string (NodeJS)\n *\n * @param {Template Literal} HTML representing a single element\n * @return {Element|String}\n */\nconst htmel = (strings, ...vals) => {\n  var out = html(strings, ...vals).trim(); // use .trim() so we never return a text node of whitespace as the result\n  // if not in a browser, return the HTML as a string\n  if (!document) return out;\n  // else, return the HTML as a proper HTML Object\n  var t = document.createElement('template');\n  t.innerHTML = out;\n  // get all elems inside our template\n  var elems = t.content.firstChild.children.length > 0 \n    ? t.content.firstChild.children \n    : t.content.firstChild;\n  // for each elem, get its attributes\n  for (var i = 0; i < elems.length; i++) {\n    var attrs = elems[i].attributes;\n    // for each attribute, check it starts with `on`\n    for (var q = 0; q < attrs.length; q++) {\n      var attr = attrs[q];\n      if (attr.name.match(/^on/)) {\n        // if attribute starts with \"on\", remove it\n        elems[i].removeAttribute(attr.name);\n        // and assign the function as a proper event listener instead\n        elems[i].addEventListener(attr.name.replace(/^on/, ''), html.funcs[attr.value])\n      }\n    }\n  }\n  return t.content.firstChild;\n}\n\nexport default htmel\n","/**\n * Enable persistant storage using localStorage\n */\nconst storage = {\n\n  getItem: (c, state) => {\n    if (!c.store) return state;\n    // console.log('getItem:', c.store, state);\n    const s = JSON.parse(localStorage.getItem(c.store))\n    return s ? { ...state, ...s } : state;\n  },\n\n  setItem: (c, state) => {\n    if (!c.store) return state;\n\n    // if Component.syncTabs is available, also keep browser tabs in\n    // sync - syncTabs will create an event which monitors localStorage\n    // changes and re-renders the given component if it's storage changed.\n    if (!c.isNode && Component.syncTabs) {\n        window.syncTab  = window.syncTab || [];\n        if (!window.syncTab[c.uid]) Component.syncTabs(c)\n    }\n\n    localStorage.setItem(c.store, JSON.stringify(state))\n  }\n\n};\n\nexport default storage;\n","/**\n * Synchronize state updates and page renders between browser tabs\n * @param {func} c - the component to re-render when it's storage updates/changes\n */\nconst syncTabs = function(c) {\n  if (c.isNode || !window) return;\n  // the \"storage\" event fires when localStorage is updated\n  window.addEventListener('storage', function (event) {\n    // if the storage obj that changed is the given components \"store\",\n    // then add the new \"store\" data to the latest state\n    if (event.key === c.store) {\n      let newState = JSON.parse(event.newValue);\n      c.setState({ ...c.state, ...newState })\n    }\n  });\n  window.syncTab[c.uid] = true\n};\n\nexport default syncTabs;\n","/**\n  The useAudio() function uses lots of code and ideas from these projects:\n\n    - https://github.com/kittykatattack/sound.js\n    - https://github.com/madebywild/audioFX\n\n  To add more features or extend useAudio, take a look at\n    - https://github.com/chrisguttandin/standardized-audio-context (a \"ponyfill\" to improve cross-browser compatibility)\n    - https://github.com/mohayonao/pseudo-audio-param (automation of props over time)\n    - https://github.com/mohayonao/adsr-envelope\n    - https://github.com/rsimmons/fastidious-envelope-generator\n    - https://github.com/Theodeus/tuna\n\n*/\n\n\n\n/**\n * useAudio - main function, creates audio objects from a library of sounds, such as mp3 files\n *\n * param sounds - an Object containing the library of sounds to create (required)\n * param c      - the Component to attach the library of sounds to (optional)\n *\n */\nconst useAudio = function(sounds, c) {\n  // if not in browser, exit\n  if (!document || !window || typeof sounds !== 'object') return;\n\n  const isArr = Array.isArray;\n  // a \"no operation\" function, used as a default setting for some callbacks\n  const noop = function noop(){ return; };\n  // minimin vol (exponentialRampToValue method of web audio API gain nodes\n  // doesn't like zero as a input, for some reason)\n  const minGain = 0.00001;\n\n  // create the global \"audio context\", or hook into an existing one\n  const ctx = window.AudioContext || window.webkitAudioContext;\n  window.audioCtx = window.audioCtx ? window.audioCtx : new ctx();\n\n  // normalize browser syntax\n  if (!audioCtx.createGain) audioCtx.createGain = audioCtx.createGainNode;\n  if (!audioCtx.createDelay) audioCtx.createDelay = audioCtx.createDelayNode;\n  // if (!audioCtx.createScriptProcessor) audioCtx.createScriptProcessor = audioCtx.createJavaScriptNode;\n\n\n  // the library of the sounds Nodes returned by this function\n  const library = {};\n  // vars used as re-usable holders, accessed in various functions, and always\n  // represent the current item in the list of sounds passed into useAudio\n  let name = null;\n  let src = null;\n  let filters = false;\n  // the list of supported filters, listed in the order they are connected..\n  // note that not all of these need to be enabled\n  const filterList = [\n   'gain', 'panning', 'reverb', 'equalizer', 'lowpass',\n   'lowshelf', 'peaking', 'notch', 'highpass', 'highshelf', 'bandpass',\n   'allpass', 'compression', 'analyser'\n  ];\n  // store audio buffer objects in here, ready to be put into bufferSourceNodes,\n  // which are high performance \"fire and forget\" audio nodes with a start()\n  // method called by play() method\n  const cache = {};\n  // set the number of files that need to be loaded\n  window.totalFiles = window.totalFiles ? window.totalFiles : 0;\n  window.totalFiles += Object.keys(sounds).length;\n  // set the number of files loaded so far\n  window.loadedFiles = window.loadedFiles ? window.loadedFiles : 0;\n\n\n\n  // download the given audio file, decode it, save it as a buffer into\n  // cache[name], then run the given callback, which is fileLoaded()\n  const loadFile = (url, item) => {\n    // if we already cached it, use the cached one\n    if (cache[name]) {\n      fileLoaded(cache[name]);\n      return;\n    }\n    // else, create a AJAX request\n    const req = new XMLHttpRequest();\n    req.open(\"GET\", url);\n    req.responseType = \"arraybuffer\";\n    // once req is completed, run this func\n    req.onload = function() {\n      // decode the response data into a buffer object, and pass it to callback\n      let d = req.response;\n      audioCtx.decodeAudioData(d, function(buffer) {\n        // run onloaded the callback\n        fileLoaded(buffer, item);\n      });\n    };\n    // report the download progress\n    req.onprogress = function (e) {\n      let percent = 0;\n      if (e.lengthComputable) {\n        percent = (e.loaded / e.total) * 100;\n      }\n      document.dispatchEvent(new CustomEvent(\"audioProgress\", { detail: { percent, url } }));\n      return percent;\n    };\n    // send the request\n    req.send();\n  };\n\n\n\n  // the callback passed into loadFile, run once the given file has loaded,\n  // receives the file as a buffer\n  const fileLoaded = (buffer, item) => {\n    // cache the buffer object\n    cache[name] = cloneBuffer(buffer);\n    // add the current sound to the library of sounds to be returned (namely,\n    // add library[name] and populate it with all the sounds props)\n    library[name] = addToLibrary(item);\n    // add the .settings({ ... }) method, for updating a sounds props, to the\n    // library collection itself - calling it will update all sounds in the\n    // library object\n    library['settings'] = (props, cb) => {\n      // update all sounds\n      Object.keys(library).forEach(audioObj => {\n        if (!library[audioObj]) return;\n        if (audioObj === 'settings') return;\n        // update the sound object with the given properties\n        if (library[audioObj].settings) library[audioObj].settings(props);\n      });\n      // then run the callback, if any\n      if (typeof cb === 'function') cb(library[audioObj].state);\n      // make it chainable\n      return library;\n    };\n\n    // add to count of files now loaded and check if all done\n    checkAllFilesLoaded();\n    // autoplay if needed\n    if (library[name].autoplay === true) library[name].play();\n  };\n\n\n  // count each file downloaded via AJAX, check if num loaded matches total\n  const checkAllFilesLoaded = () => {\n    window.loadedFiles += 1;\n    // check if all files loaded\n    if (window.totalFiles === window.loadedFiles) {\n      document.dispatchEvent(new CustomEvent(\"audioLoaded\", { detail: library }));\n    }\n  };\n\n  // clone a buffer object, so we can save it to the cache before playing it\n  // (after which the buffer normally disappears and is garbage collected)\n  const cloneBuffer = inBuffer => {\n    let outBuffer = audioCtx.createBuffer(\n      inBuffer ? inBuffer.numberOfChannels : 2,\n      inBuffer ? inBuffer.length : 0,\n      inBuffer ? inBuffer.sampleRate : audioCtx.sampleRate\n    );\n    for (var i = 0, c = inBuffer.numberOfChannels; i < c; ++i) {\n      let od = outBuffer.getChannelData(i),\n        id = inBuffer.getChannelData(i);\n      od.set(id, 0);\n    }\n    return outBuffer;\n  }\n\n\n\n  // create the sound Object and add it to the library that we return\n  const addToLibrary = (item) => {\n    // library is the main object returned by useAudio(), and \"name\" is the\n    // name of the current sound object being added (\"name\" is defined in main\n    // loop near end of the script)\n\n    const obj = {\n      // set some properties\n      name,\n      src, // should be a string (URL to audio file), another sound object, or an array of sound objects\n      // the main methods\n      play,\n      playFrom,\n      pause,\n      fadeIn,\n      fadeOut,\n      rapidFire,\n      stop,\n      mute,\n      unmute,\n      connectTo,\n      // callbacks\n      onPlay: item[1].onPlay || noop,\n      onPause: item[1].onPause || noop,\n      onResume: item[1].onResume || noop,\n      onStop: item[1].onStop || noop,\n      onChange: item[1].onChange || noop,  // fired when a prop in state changes or sound is -reconnected\n      // set input node:\n      input: audioCtx.createBufferSource(),\n      // set output node:\n      // - output to the default output of the Audio Context all our sounds use\n      output: audioCtx.destination,\n      // set audio nodes:\n      // the actual audio nodes that will be connected and form the audio graph..\n      // this will be created by the play() method, and will include input/output\n      // above... NOTE: if defined, equaliser nodes end up in their own array,\n      // separate from this list of audio nodes, so that we can keep track of\n      // which nodes are used for what, and that the equaliser can be adjusted\n      // as a single \"thing\", via settings\n      audioNodes: [],\n      // set audio properties:\n      // all audio nodes have these settings applied to them where relevant,\n      // and the play(), pause() etc  methods check for and respect these\n      // settings. All filter settings will be added to state too. The state\n      // should be updated using the mySound.settings({ ... }) method.\n      state: {\n        isPlaying: false,                         // boolean\n        volume: item[1].volume || 1,              // 0 is slient, 1 is 100%, 2 is 200%\n        muted: item[1].muted || false,            // false is not muted\n        autoplay: item[1].autoplay || false,      // boolean\n        loop: item[1].loop || false,              // boolean\n        playbackRate: item[1].playbackRate || 1,  // 1 is normal speed, 2 is double speed\n        //detune: item[1].detune || 0,              // 1200 is up 1 octave, -1200 is down 1 octave\n        startTime: item[1].startTime || 0,        // start time of the sound, when played\n        startOffset: item[1].startOffset || 0,    // used to help track pause/resume/play times\n        //fadeIn: item[1].fadeIn || 0,              // duration in seconds\n        //fadeOut: item[1].fadeOut || 0,            // duration in seconds\n      },\n      // this is the mySound.settings() method... it allows updating the props\n      // of individual sounds with mySound.settings({ ... }) - pass in only\n      // the options you want to change.\n      settings: function(props, cb) {\n        // check if prop relates to an existing audio node or not\n        Object.keys(props).forEach(key => {\n          const rebuildNodes = filterList.indexOf(key) !== -1 && isDisabled(obj.state[key]) !== isDisabled(props[key]);\n          if (rebuildNodes) {\n            obj.state = { ...obj.state, ...props };\n            obj.audioNodes = createNodes(obj);\n            connectNodes(obj);\n            if (obj.state.isPlaying) obj.playFrom(audioCtx.currentTime);\n          }\n        });\n        obj.state = { ...obj.state, ...props };\n        randomiseSound(obj);\n        // update settings of each audio node\n        setupNodesFor(obj);\n        if (typeof cb === 'function') cb(obj.state);\n        // setting have changed, call the relevant callback\n        obj.onChange(obj.state);\n        // return the whole sound object\n        return obj;\n      },\n    };\n    // create all audio nodes that we need\n    obj.audioNodes = createNodes(obj);\n    return obj;\n  }\n\n\n  const randomiseSound = (soundObj) => {\n    const s = soundObj.state;\n    // randomise sound if need be\n    if (typeof s.randomization === 'object') {\n      const r = s.randomization;\n      if (r.volume) s.volume = s.volume + (Math.random() * r.volume);\n      if (r.playbackRate) s.playbackRate = s.playbackRate + (Math.random() * r.playbackRate);\n      if (r.startOffset) s.startOffset = s.startOffset + 1 * (0.01 + Math.random() * r.startOffset);\n      if (r.delay && getAudioNode(soundObj, 'delay')) s.delay = s.delay * (0.01 + Math.random() * r.delay);\n    }\n  }\n\n  // for each audio node in soundObj, apply settings from state - this function\n  // is called by the setting() method and play(), etc.\n  const setupNodesFor = (soundObj) => {\n    const s = soundObj.state;\n    // configure the input node\n    soundObj.input.loop = s.loop;\n    soundObj.input.playbackRate.value = s.playbackRate;\n    // for each sound property in soundObject.state\n    Object.keys(s).forEach(key => {\n      const nodeType = key === 'volume' ? 'gain' : key;\n      // get the audio node of type 'nodeType'\n      let node = getAudioNode(soundObj, nodeType);\n      // get opts/values of the current prop (key) in sound objects state\n      // set the value based on the property (key) in the state\n      if (node && !isDisabled(s[key])) {\n        setNodeProps(soundObj, node, s[key]);\n      }\n    });\n  };\n\n\n  // helper func - check if an audio node is disabled in the options\n  const isDisabled = n => n === undefined || n === null || n === false;\n\n  // create all audio nodes defined in sound settings, and return them in an array\n  const createNodes = (soundObj) => {\n    // define a list of all audio nodes needed in the chain\n    const graph = [\n      soundObj.input, // the input node\n    ];\n    // get filter opts\n    const filterNodes = {};\n    // always create a gain node, as they're not listed with the other filters\n    // in the config pass to us by user\n    const allFilters = {\n      gain: soundObj.state.volume,\n      ...filters,\n      ...soundObj.state,\n    };\n    // create a filter node for each one defined\n    Object.keys(allFilters).forEach(type => {\n      // get the options for this filter\n      const opts = allFilters[type];\n      // skip filter is no valid settings given\n      if (isDisabled(opts)) return;\n      // create filter and add to a list of all enabled filters\n      filterNodes[type] = createFilterNode(soundObj, type, opts);\n      // add filter settings to state\n      const prop = type === 'gain' ? 'volume' : type;\n      soundObj.state[prop] = opts;\n      if (filterNodes[type]) {\n        // set audio nodes props to match values in the sounds state\n        setNodeProps(soundObj, filterNodes[type], opts);\n      }\n    });\n    // now sort all filterNodes into the \"proper\" order\n    filterList.forEach(type => {\n      // attach the node in the list (type)\n      if (filterNodes[type] && type !== 'equalizer') {\n        graph.push(filterNodes[type]);\n      }\n      // add all the equalizer nodes, which are not in filterNodes,\n      // but in the soundObj.eq array\n      else if (type === 'equalizer' && isArr(soundObj.eq)) {\n        soundObj.eq.forEach(node => graph.push(node));\n      }\n    });\n    // add the output node to the graph\n    graph.push(soundObj.output)\n    return graph;\n  };\n\n\n  // create filter nodes of given \"type\", with options \"o\" for soundObject \"s\"\n  const createFilterNode = (s, type, o) => {\n    let n = undefined; // the node to return\n    switch (type) {\n      case 'gain':\n      case 'volume':\n        n = audioCtx.createGain();\n        break;\n      case 'panning':\n        if (!audioCtx.createStereoPanner) {\n          n = audioCtx.createPanner();\n        } else {\n          n = audioCtx.createStereoPanner();\n        }\n        break;\n      //case 'panning3d':\n      //  n = audioCtx.createPanner();\n      //  break;\n      case 'delay':\n        n = audioCtx.createDelay();\n        break;\n      case 'lowpass':\n      case 'highpass':\n      case 'bandpass':\n      case 'allpass':\n      case 'lowshelf':\n      case 'highshelf':\n      case 'peaking':\n      case 'notch':\n        n = audioCtx.createBiquadFilter();\n        break;\n      case 'equalizer':\n        // we need to return an \"audio node\" to put into our graph array, but\n        // we don't wanna create only one node for our equalizer, so\n        // return a fake node into the list, of type \"equalizer\", and add\n        // all the nodes we need to a separate array - we'll parse the fake\n        // node of type \"equalizer\" in setNodeProps(), and access it's array\n        // of nodes there\n        n = {\n          type: 'equalizer',\n        };\n        // create the array that holds each filter node (each is a eq band)\n        s.eq = [];\n        // each obj in o is a filter settings obj, so create an audio node\n        // for each one, with the correct type\n        //if (o && o.length && o.length > 0) {\n        o.forEach((eq, i) => {\n          const eqNode = audioCtx.createBiquadFilter();\n          if (i === 0) {\n            eqNode.type = 'lowpass';\n          }\n          else if (i === (o.length - 1)) {\n            eqNode.type = 'highpass';\n          }\n          else {\n            eqNode.type = 'peaking';\n          }\n          // add each audio node to the \"equalizer\" array\n          s.eq.push(eqNode);\n        });\n        //}\n        break;\n      case 'reverb':\n        n = audioCtx.createConvolver();\n        break;\n      case 'analyser':\n        n = audioCtx.createAnalyser();\n        break;\n      case 'compression':\n        n = audioCtx.createDynamicsCompressor();\n        break;\n      default:\n        break;\n    }\n    // set a type (used in createNodes() to filter node list)\n    if (n) n.type = type;\n    // return the audio node\n    return n;\n  };\n\n\n\n  // TODO smoother settings changes: also use \"linearRampToValueAtTime\", or \"exponentialRampToValueAtTime\"\n  // TODO clamp values between the min/max of the AudioParam type:\n  //        - gain: min  0, max  1\n  //        - pan: min  -1, max  1\n  //        - ..\n  // set the props of the given audio node (n) to match the values in the\n  // current sounds state options (o) for the given sound object (s)\n  const setNodeProps = (s, n, o) => {\n    const type = n.type;\n    const ct = audioCtx.currentTime;\n\n    // helper functions, to check and set filter values\n    const has = prop => typeof o === 'number' || typeof o[prop] === 'number';\n    const setVal = (prop, v) => n[prop].setValueAtTime(v, ct);\n    const setFreq = () => n.frequency.setValueAtTime(o.freq, ct);\n    const setGain = () => n.gain.setValueAtTime(o.gain, ct);\n    const setQ = () => n.Q.setValueAtTime(o.q, ct)\n\n    switch (type) {\n      case 'volume':\n      case 'gain':\n        // dont let \"v\" go below zero\n        let v = o <= 0 ? minGain : o;\n        // set to zero if muted\n        if (s.state.mute === true) v = minGain;\n        // update the node and state\n        //s.state.volume = v;\n        n.gain.setValueAtTime(v, ct);\n        //n.gain.value = v;\n        break;\n      case 'panning':\n        if (!audioCtx.createStereoPanner) {\n          //Panner objects accept x, y and z coordinates for 3D\n          //sound. However, because we're only doing 2D left/right\n          //panning we're only interested in the x coordinate,\n          //the first one. However, for a natural effect, the z\n          //value also has to be set proportionately.\n          const y = 0;\n          const z = 1 - Math.abs(o);\n          n.setPosition(o, y, z);\n          n.panValue = o;\n        } else {\n          setVal('pan', typeof o === 'number' ? o : 0);\n        }\n        //s.state.panning = o;\n        break;\n      //case 'panning3d':\n      //  // TODO\n      //  break;\n      case 'delay':\n        setVal('delayTime', typeof o === 'number' ? o : 0);\n        break;\n      case 'lowpass':\n      case 'highpass':\n      case 'bandpass':\n      case 'allpass':\n      case 'lowshelf':\n      case 'highshelf':\n      case 'peaking':\n      case 'notch':\n      \tif (has('freq')) setFreq();\n      \tif (has('gain')) setGain();\n      \tif (has('q')) setQ();\n        break;\n      case 'reverb':\n        if (o) {\n          // to allow only some props to be passed in let's merge `o` with defaults and state\n          const opts = { duration: 1, decay: 1, reverse: false, ...s.state.reverb, ...o };\n          // set the reverb\n          n.buffer = impulseResponse(opts.duration, opts.decay, opts.reverse);\n          // update state, so it contains all reverb settings\n          s.state.reverb = opts;\n        } else {\n          n.buffer = null;\n        }\n        break;\n      case 'equalizer':\n        // Note - the equalizer is an array of nodes, so don't set props on 'n',\n        // instead loop over the array and set props for each\n        if (isArr(s.eq)) {\n          // get each filter in equalizer, and apply the settings in 'opts'\n          o.forEach((opts, i) => {\n            const node = s.eq[i];\n            if (typeof opts.freq === 'number') {\n              node.frequency.value = opts.freq;\n//              node.frequency.setValueAtTime(opts.freq, ct);\n            }\n            if (typeof opts.gain === 'number') {\n              node.gain.value = opts.gain;\n//              node.gain.setValueAtTime(opts.gain, ct);\n            }\n            if (typeof opts.q === 'number') {\n              node.Q.value = opts.q;\n//              node.Q.setValueAtTime(opts.q, ct);\n            }\n          });\n        }\n        break;\n      case 'analyser':\n        if (has('fftSize')) n.fftSize = o.fftSize;\n        if (has('minDecibels')) n.minDecibels = o.minDecibels;\n        if (has('maxDecibels')) n.maxDecibels = o.maxDecibels;\n        if (has('smoothingTimeConstant')) n.smoothingTimeConstant = o.smoothingTimeConstant;\n        // now we add some useful props for visualisations to the sounds state:\n        // 1. add the analyser node to state\n        s.state.visualiser = n;\n        break;\n      case 'compression':\n        if (has('threshold')) setVal('threshold', o.threshold);\n        if (has('knee')) setVal('knee', o.knee);\n        if (has('ratio')) setVal('ratio', o.ratio);\n        if (has('attack')) setVal('attack', o.attack);\n        if (has('release')) setVal('release', o.release);\n        break;\n      default:\n        break;\n    }\n  }\n\n\n\n  // public method on soundObjs\n  // play the sound\n  const play = () => {\n    const s = library[name];\n    const state = s.state;\n    // get the input node\n    const input = audioCtx.createBufferSource();\n    // set the sound nodes buffer property to the (down)loaded sound\n    input.buffer = cloneBuffer(cache[name]);\n    // randomise sound if need be\n    randomiseSound(s);\n    // configure the input node\n    input.loop = state.loop;\n    input.playbackRate.value = state.playbackRate;\n    //input.detune.value += state.detune;\n    s.input = input;\n    // create the nodes\n    s.audioNodes = createNodes(s);\n    // now connect the audio nodes, in the proper order\n    connectNodes(s);\n    // set all properties on the relevent audio nodes to match the sounds \"state\"\n    setupNodesFor(s); // not needed...?\n    // normalize for better browser support\n    if (!input.start) input.start = input.noteOn;\n    // play the sound\n    input.start(state.startTime, state.startOffset % input.buffer.duration);\n    state.isPlaying = true;\n    // play any other sounds which have been \"connected\" to this one\n    if (isArr(s.attachedSounds)) {\n      s.attachedSounds.forEach(snd => {\n        if (!snd.state.isPlaying) snd.playFrom(audioCtx.currentTime);\n      });\n    }\n    // enable fade in if needed\n    if (typeof state.fadeIn === 'number' && state.fadeIn > 0) {\n      fadeIn(state.fadeIn);\n    }\n    // run the callbacks\n    if (state.startOffset === 0) s.onPlay(state);\n    if (state.startOffset > 0) s.onResume(state);\n  };\n\n\n  // internal method, used by play(), rapidFire(), to connect up the audio nodes\n  // before playing the sound\n  const connectNodes = (soundObj) => {\n    // connect all enabled audio nodes\n    soundObj.audioNodes.forEach((n, i) => {\n      const curr = n;\n      const next = soundObj.audioNodes[i + 1];\n      const prev =  i > 0 ? soundObj.audioNodes[i - 1] : null;\n      if (curr && next && curr.connect) {\n        // if next node is the equalizer, connect the equalizer nodes\n        if (next.type === 'equalizer') {\n          curr.connect(soundObj.eq[0]);\n          // go through each eq node and connect them up\n          soundObj.eq.forEach((eqNode, num) => {\n            if (soundObj.eq[num] && soundObj.eq[num + 1]) {\n              soundObj.eq[num].connect(soundObj.eq[num + 1]);\n            }\n          });\n        }\n        else if (prev && prev.type === 'equalizer') {\n          // if prev node was the equalizer, connect its last node up to\n          // the current node in the list\n          soundObj.eq[soundObj.eq.length - 1].connect(curr);\n          curr.connect(next);\n        } else {\n          // no need to connect to/from equaliser, so just connect up the\n          // current node \"curr\" to \"next\" node\n          curr.connect(next);\n        }\n      }\n    });\n  };\n\n  // public method on soundObjs - play a sound multiple times\n  // param \"count\"    number of times to play the sound\n  // param \"delay\"    number of milliseconds delay between in play\n  const rapidFire = (count, delay) => {\n    const num = count ? count : 3;\n    const dly = delay ? delay : 200;\n    // Make multiple sources using the same buffer and play in quick succession.\n    for (let i = 0; i < num; i++) {\n      // disable looping for this sound while rapid firing\n      const loopSetting = library[name].state.loop;\n      library[name].state.loop = false;\n      setTimeout(play, dly);\n      // restore loop setting\n      library[name].state.loop = loopSetting;\n    }\n  }\n\n\n  // public method on soundObjs\n  const pause = () => {\n      //Pause the sound if it's playing, and calculate the\n      //`startOffset` to save the current position.\n      if (library[name].state.isPlaying) {\n        library[name].state.startOffset = audioCtx.currentTime - library[name].state.startTime;\n        library[name].input.stop(0);\n        library[name].state.isPlaying = false;\n        // run the callback\n        library[name].onPause(library[name].state);\n        // pause any other sounds which have been \"connected\" to this one\n        if (isArr(library[name].attachedSounds)) {\n          library[name].attachedSounds.forEach(snd => {\n            if (snd.state.isPlaying) snd.pause();\n          });\n        }\n      }\n  };\n\n\n  // public method on soundObjs\n  const playFrom = (time) => {\n      try {\n        library[name].input.stop(0);\n      } catch (e) {};\n      library[name].state.startOffset = time;\n      library[name].play();\n  };\n\n\n  // public method on soundObjs\n  const stop = () => {\n    //Stop the sound if it's playing, reset the start and offset times,\n    //then call the `play` method again.\n    if (library[name].state.isPlaying) {\n      library[name].input.stop(0);\n      library[name].state.isPlaying = false;\n      library[name].state.startOffset = 0;\n      // run the callback\n      library[name].onStop(library[name].state);\n      // stop any other sounds which have been \"connected\" to this one\n      if (isArr(library[name].attachedSounds)) {\n        library[name].attachedSounds.forEach(snd => {\n          if (snd.state.isPlaying) snd.stop();\n        });\n      }\n    }\n  };\n\n  // public method on soundObjs\n  const mute = () => {\n    // set a previous volume, so we can restore it\n    library[name].state.prevVol = library[name].state.volume;\n    library[name].settings({\n      volume: 0,\n      muted: true,\n    });\n    // mute any other sounds which have been \"connected\" to this one\n    if (isArr(library[name].attachedSounds)) {\n      library[name].attachedSounds.forEach(snd => {\n        if (snd.state.isPlaying) snd.mute();\n      });\n    }\n  }\n\n  // public method on soundObjs\n  const unmute = () => {\n    library[name].settings({\n      volume: library[name].state.prevVol,\n      prevVol: undefined,\n      muted: false,\n    });\n    // unmute any other sounds which have been \"connected\" to this one\n    if (isArr(library[name].attachedSounds)) {\n      library[name].attachedSounds.forEach(snd => {\n        if (snd.state.isPlaying) snd.unmute();\n      });\n    }\n  }\n\n\n  // public method on soundObjs\n  // method added to sound object to let users re-connect sounds, by doing\n  // soundObj.connectTo(otherSoundObj);\n  const connectTo = (otherSound) => {\n    // update the sound props to output to the other sound\n    otherSound.attachedSounds = otherSound.attachedSounds || [];\n    otherSound.attachedSounds.push(library[name]);\n    // setting have changed, call the relevant callback\n    library[name].onChange(library[name].state);\n  };\n\n\n  // helper func to get an audio node by type (useAudio always add a type\n  // property to audio nodes, even if they don't normally have them)\n  const getAudioNode = (soundObj, type) => {\n    if (!soundObj.audioNodes) return;\n    return soundObj.audioNodes.filter(n => n.type === type)[0];\n  };\n\n  // public method on soundObjs\n  const fadeIn = function(durationInSeconds, endVol) {\n      if (!library[name].state.isPlaying) library[name].play();\n      fade(endVol ? endVol : 1, durationInSeconds);\n  };\n\n\n  // public method on soundObjs\n  const fadeOut = function (durationInSeconds) {\n      fade(minGain, durationInSeconds);\n  };\n\n\n  // helper func called by fadeIn() and fadeOut()\n  const fade = function (endValue, durationInSeconds) {\n      const gn = getAudioNode(library[name], 'gain');\n      const ct = audioCtx.currentTime;\n      const s = library[name].state;\n      // set the value to transition *from*\n      gn.gain.value = s.volume;\n      if (s.isPlaying) {\n        gn.gain.setValueAtTime(s.volume, ct);\n        // now the values to transition *to*\n        gn.gain.exponentialRampToValueAtTime(endValue, ct + durationInSeconds);\n        s.volume = endValue;\n      }\n  };\n\n\n  // simulate a model of sound reverberation in an acoustic space which\n  // a convolver node can blend with the source sound.\n  function impulseResponse(duration, decay, reverse) {\n    //The length of the buffer.\n    const length = audioCtx.sampleRate * duration;\n    //Create an audio buffer to store the reverb effect.\n    const impulse = audioCtx.createBuffer(2, length, audioCtx.sampleRate);\n    //Use `getChannelData` to initialize empty arrays to store sound data for\n    //the left and right channels.\n    const left  = impulse.getChannelData(0);\n    const right = impulse.getChannelData(1);\n    //Loop through each sample-frame and fill the channel\n    //data with random noise.\n    let n;\n    if (reverse) {\n      //Apply the reverse effect, if `reverse` is `true`.\n      for (let i = 0; i < length; i++) {\n        n = length - i;\n        let multi = Math.pow(1 - n / length, decay)\n        left[n] = (Math.random() * 0.5) * multi;\n        right[n] = (Math.random() * 0.5) * multi;\n      }\n    } else {\n      for (let i = 0; i < length; i++) {\n        n = i;\n        let multi = Math.pow(1 - n / length, decay)\n        left[i] = (Math.random() * 0.5) * multi;\n        right[i] = (Math.random() * 0.5) * multi;\n      }\n    }\n    //Return the `impulse`.\n    return impulse;\n  }\n\n\n  //\n  // MAIN LOOP - parse each sound given in 'sounds' param\n  //\n  Object.entries(sounds).forEach(item => {\n    // work out some info about the sound\n    const hasFilters = typeof item[1] === 'object' && typeof item[1].filters === 'object';\n    name = item[1].name || item[0];\n    src = item[1].src || item[1];\n    filters = hasFilters ? item[1].filters : undefined;\n    // create the sound object for \"item\"\n    library[name] = null;\n    // create an item in cache that will hold a  buffer, in which we will store\n    // the audio data returned from an AJAX request\n    cache[name] = null;\n    // download audio file, save it as a buffer in the fileLoaded() callback,\n    // then add the sound to the library to be returned\n    loadFile(src, item);\n  });\n\n  // attach all our sounds to the given component, if any\n  if (c) c.audio = library;\n\n  // return all the sounds\n  return library;\n};\n\n\n// finally, export the main function\n//\nexport default useAudio;\n","const onScroll = (fn, c) => {\n  if (!document) return;\n\n  const cb = function() {\n    // get document bounds\n    const pageBounds = document.body.getBoundingClientRect();\n    // get guideline (marker) position\n    const offset = c.onScroll.offset || 35;\n    const guideline = document.documentElement.clientHeight / 100 * offset; // 50% of page height\n    // debounce scroll updates to 60fps\n    requestAnimationFrame(totalFrames => {\n      // get component position, relative to guideline (marker)\n      const bounds = c.html.getBoundingClientRect();\n      const outside = bounds.top > guideline || bounds.bottom < guideline;\n      let progress = (guideline - bounds.top) / bounds.height;\n      if (bounds.top >= guideline) progress = 0;\n      if (bounds.bottom <= guideline) progress = 1;\n      c.onScroll.frame = !outside ? (c.onScroll.frame || 0) + 1 : 0;\n      //\n      let direction = null;\n      if (c.onScroll.frame !== 0) {\n        direction = c.onScroll.prevPos < progress ? 'down' : 'up'\n      }\n      // setup the props to return\n      const scrollProps = {\n        frame: c.onScroll.frame,\n        totalFrames: +totalFrames.toFixed(0),\n        progress: +progress.toFixed(2),\n        direction: direction,\n      };\n      // run the given function, pass in current scroll props\n      fn(scrollProps)\n      c.onScroll.prevPos = progress;\n    });\n  };\n\n  if (!c.onScroll.ready) {\n    window.addEventListener('scroll', cb);\n    c.onScroll.ready = true;\n  }\n}\n\nexport default onScroll;\n","// Taken from: \n// https://github.com/getify/TNG-Hooks/blob/master/src/tng-hooks.src.js\n\n// Changes: \n// 1. main function renamed to useHooks()\n// 2. added useDeferred and useThrottle from forks\n\n(function UMD(context,definition){\n  /* istanbul ignore next */if (typeof define === \"function\" && define.amd) { define(definition); }\n  /* istanbul ignore next */else if (typeof module !== \"undefined\" && module.exports) { module.exports = definition(); }\n  /* istanbul ignore next */else { Object.assign(context,definition()); }\n})(this,function DEF(){\n  \"use strict\";\n\n  var buckets = new WeakMap();\n  var tngStack = [];\n\n  return {\n    useHooks, useState, useReducer, useEffect,\n    useMemo, useCallback, useRef, useDeferred,\n    useThrottle\n  };\n\n\n  // ******************\n\n  function useHooks(...fns) {\n    fns = fns.map(function mapper(fn){\n      tngf.reset = reset;\n      return tngf;\n\n\n      // ******************\n\n      function tngf(...args) {\n        tngStack.push(tngf);\n        var bucket = getCurrentBucket();\n        bucket.nextStateSlotIdx = 0;\n        bucket.nextEffectIdx = 0;\n        bucket.nextMemoizationIdx = 0;\n\n        try {\n          return fn.apply(this,args);\n        }\n        finally {\n          // run (cleanups and) effects, if any\n          try {\n            runEffects(bucket);\n          }\n          finally {\n            tngStack.pop();\n          }\n        }\n      }\n\n      function runEffects(bucket) {\n        for (let [idx,[effect,guards]] of bucket.effects.entries()) {\n          try {\n            if (typeof effect == \"function\") {\n              effect();\n            }\n          }\n          finally {\n            bucket.effects[idx][0] = undefined;\n          }\n        }\n      }\n\n      function reset() {\n        tngStack.push(tngf);\n        var bucket = getCurrentBucket();\n        try {\n          // run all pending cleanups\n          for (let cleanup of bucket.cleanups) {\n            if (typeof cleanup == \"function\") {\n              cleanup();\n            }\n          }\n        }\n        finally {\n          tngStack.pop();\n          bucket.stateSlots.length = 0;\n          bucket.effects.length = 0;\n          bucket.cleanups.length = 0;\n          bucket.memoizations.length = 0;\n          bucket.nextStateSlotIdx = 0;\n          bucket.nextEffectIdx = 0;\n          bucket.nextMemoizationIdx = 0;\n        }\n      }\n    });\n\n    return (fns.length < 2) ? fns[0] : fns;\n  }\n\n\n  function getCurrentBucket() {\n    if (tngStack.length > 0) {\n      let tngf = tngStack[tngStack.length - 1];\n      let bucket;\n      if (!buckets.has(tngf)) {\n        bucket = {\n          nextStateSlotIdx: 0,\n          nextEffectIdx: 0,\n          nextMemoizationIdx: 0,\n          stateSlots: [],\n          effects: [],\n          cleanups: [],\n          memoizations: [],\n        };\n        buckets.set(tngf,bucket);\n      }\n\n      return buckets.get(tngf);\n    }\n  }\n\n  function useState(initialVal) {\n    var bucket = getCurrentBucket();\n    // console.log('useState:bucket', bucket);\n    if (bucket) {\n      const reducer = function reducer(prevVal,vOrFn) {\n        // console.log('useState:reducer', prevVal,vOrFn);\n        return typeof vOrFn == \"function\" ?\n          vOrFn(prevVal) :\n          vOrFn;\n      };\n      return useReducer(reducer,initialVal);\n    }\n    else {\n      throw new Error(\"useState() only valid inside an Articulated Function or a Custom Hook.\");\n    }\n  }\n\n  function useThrottle(fn, timer, ...guards) {\n    if(!fn) { throw new TypeError('useThrottle() requires a function argument')}\n    if(!timer) { throw new TypeError('useThrottle() requires a timer argument')}\n\n    var bucket = getCurrentBucket();\n    if (bucket) {\n      const [slot] = useState({fn, timer, lastExecute: 0});\n\n      if (guards.length > 0) {\n        if (guards.length === 1 && Array.isArray(guards[0])) {\n          guards = guards[0];\n        }\n      }\n\n      if (!slot.throttledFn || guardsChanged(slot.guards, guards)) {\n        slot.guards = guards;\n        slot.timer = timer;\n        slot.fn = fn;\n        slot.throttledFn =  function throttledFunction(...args) {\n          const {fn, timer, lastExecute} = slot;\n          const currentTime = Date.now();\n\n          if(lastExecute + timer < currentTime) {\n            try {\n              fn.apply(this, args);\n            } finally {\n              slot.lastExecute = currentTime;\n            }\n          }\n        };\n      }\n\n      return slot.throttledFn;\n\n    }\n    else {\n      throw new Error(\"useThrottle() only valid inside an Articulated Function or a Custom Hook.\");\n    }\n  }\n\n  function useReducer(reducerFn,initialVal,...initialReduction) {\n    var bucket = getCurrentBucket();\n    if (bucket) {\n      // need to create this state-slot for this bucket?\n      if (!(bucket.nextStateSlotIdx in bucket.stateSlots)) {\n        let slot = [\n          typeof initialVal == \"function\" ? initialVal() : initialVal,\n          function updateSlot(v){\n            slot[0] = reducerFn(slot[0],v);\n          },\n        ];\n        bucket.stateSlots[bucket.nextStateSlotIdx] = slot;\n\n        // run the reducer initially?\n        if (initialReduction.length > 0) {\n          bucket.stateSlots[bucket.nextStateSlotIdx][1](initialReduction[0]);\n        }\n      }\n\n      return [...bucket.stateSlots[bucket.nextStateSlotIdx++]];\n    }\n    else {\n      throw new Error(\"useReducer() only valid inside an Articulated Function or a Custom Hook.\");\n    }\n  }\n\n  // NOTE: both `guards1` and `guards2` are either\n  //    `undefined` or an array\n  function guardsChanged(guards1,guards2) {\n    // either guards list not set?\n    if (guards1 === undefined || guards2 === undefined) {\n      // force assumption of change in guards\n      return true;\n    }\n\n    // guards lists of different length?\n    if (guards1.length !== guards2.length) {\n      // guards changed\n      return true;\n    }\n\n    // check guards lists for differences\n    //    (only shallow value comparisons)\n    for (let [idx,guard] of guards1.entries()) {\n      if (!Object.is(guard,guards2[idx])) {\n        // guards changed\n        return true;\n      }\n    }\n\n    // assume no change in guards\n    return false;\n  }\n\n  function useEffect(fn,...guards) {\n    // passed in any guards?\n    if (guards.length > 0) {\n      // only passed a single guards list?\n      if (guards.length == 1 && Array.isArray(guards[0])) {\n        guards = guards[0];\n      }\n    }\n    // no guards passed\n    // NOTE: different handling than an empty guards list like []\n    else {\n      guards = undefined;\n    }\n\n    var bucket = getCurrentBucket();\n    if (bucket) {\n      // need to create this effect-slot for this bucket?\n      if (!(bucket.nextEffectIdx in bucket.effects)) {\n        bucket.effects[bucket.nextEffectIdx] = [];\n      }\n\n      let effectIdx = bucket.nextEffectIdx;\n      let effect = bucket.effects[effectIdx];\n\n      // check guards?\n      if (guardsChanged(effect[1],guards)) {\n        // define effect handler\n        effect[0] = function effect(){\n          // run a previous cleanup first?\n          if (typeof bucket.cleanups[effectIdx] == \"function\") {\n            try {\n              bucket.cleanups[effectIdx]();\n            }\n            finally {\n              bucket.cleanups[effectIdx] = undefined;\n            }\n          }\n\n          // invoke the effect itself\n          var ret = fn();\n\n          // cleanup function returned, to be saved?\n          if (typeof ret == \"function\") {\n            bucket.cleanups[effectIdx] = ret;\n          }\n        };\n        effect[1] = guards;\n      }\n\n      bucket.nextEffectIdx++;\n    }\n    else {\n      throw new Error(\"useEffect() only valid inside an Articulated Function or a Custom Hook.\");\n    }\n  }\n\n  function useMemo(fn,...inputGuards) {\n    // passed in any input-guards?\n    if (inputGuards.length > 0) {\n      // only passed a single inputGuards list?\n      if (inputGuards.length == 1 && Array.isArray(inputGuards[0])) {\n        inputGuards = inputGuards[0];\n      }\n    }\n    // no input-guards passed\n    // NOTE: different handling than an empty inputGuards list like []\n    else {\n      // the function itself is then used as the only input-guard\n      inputGuards = [fn];\n    }\n\n    var bucket = getCurrentBucket();\n    if (bucket) {\n      // need to create this memoization-slot for this bucket?\n      if (!(bucket.nextMemoizationIdx in bucket.memoizations)) {\n        bucket.memoizations[bucket.nextMemoizationIdx] = [];\n      }\n\n      let memoization = bucket.memoizations[bucket.nextMemoizationIdx];\n\n      // check input-guards?\n      if (guardsChanged(memoization[1],inputGuards)) {\n        try {\n          // invoke the to-be-memoized function\n          memoization[0] = fn();\n        }\n        finally {\n          // save the new input-guards\n          memoization[1] = inputGuards;\n        }\n      }\n\n      bucket.nextMemoizationIdx++;\n\n      // return the memoized value\n      return memoization[0];\n    }\n    else {\n      throw new Error(\"useMemo() only valid inside an Articulated Function or a Custom Hook.\");\n    }\n  }\n\n  function useCallback(fn,...inputGuards) {\n    if (getCurrentBucket()) {\n      return useMemo(function callback(){ return fn; },...inputGuards);\n    }\n    else {\n      throw new Error(\"useCallback() only valid inside an Articulated Function or a Custom Hook.\");\n    }\n  }\n\n  function useRef(initialValue) {\n    if (getCurrentBucket()) {\n      // create a new {} object with a `current` property,\n      // save it in a state slot\n      var [ref] = useState({ current: initialValue, });\n      return ref;\n    }\n    else {\n      throw new Error(\"useRef() only valid inside an Articulated Function or a Custom Hook.\");\n    }\n  }\n\n  function useDeferred() {\n    if (getCurrentBucket()) {\n      const [deferred] = useState((function () {\n        let resolve, reject;\n        let pr = new Promise((res, rej) => {\n          resolve = res;\n          reject = rej;\n        })\n\n        return { pr, resolve, reject }\n      })())\n\n      return deferred\n    } else {\n      throw new Error(\"useDeferred() only valid inside an Articulated Function or a Custom Hook.\")\n    }\n  }\n\n});\n"],"names":["domDiff","t","s","d","document","job","cfg","orig","[object Object]","v","createElement","innerHTML","vHTML","content","firstChild","nextElementSibling","nodeName","this","loop","parentElement","replaceChild","tn","sn","tOrig","checkNew","checkNodeName","checkCtx","nodeType","checkAttrs","childNodes","lengthDiff","Array","apply","forEach","node","idx","n","cloneNode","attrs","attributes","filteredAttrs","Object","keys","map","attrsNew","filteredAttrsNew","o","getAttribute","name","setAttribute","removeAttribute","a","nodeValue","textContent","tParent","undefined","newNode","appendChild","removeChild","create","replace","Component","state","schema","c","setState","container","C","validator","emitter","tweenState","springTo","strg","storage","useAudio","onScroll","onLoop","devtools","cache","memo","f","O","R","RegExp","timeout","w","raf","reactive","immutable","debug","scopedCss","i","log","id","action","length","view","props","middleware","uid","Math","random","toString","split","isNode","process","versions","window","requestAnimationFrame","css","head","actions","actionsList","axn","newState","freeze","isFrozen","k","eq","x","y","ok","tx","every","key","String","nextState","done","pState","getItem","err","msg","console","error","Error","JSON","stringify","prev","setItem","render","ctx","cancelAnimationFrame","tt","logFn","setTimeout","push","emit","fn","opts","minFps","targetFps","maxRestarts","Infinity","runTime","forceSetTimeout","autoResume","start","stop","pause","resume","on","ev","once","off","go","num","dir","rw","ff","setCss","style","st","p","u","className","fx1","fx2","fx3","fx","minCss","outerHTML","parse","isArray","toStr","el","ctxType","html","querySelector","getContext","firstElementChild","append","populateUI","sjComponents","sel","now","require","performance","root","global","vendors","suffix","caf","last","queue","callback","_now","next","max","cp","slice","cancelled","e","round","handle","module","exports","call","cancel","arguments","polyfill","object","easing","linear","inQuad","outQuad","inOutQuad","inCubic","outCubic","inOutCubic","inQuart","outQuart","inOutQuart","inQuint","outQuint","inOutQuint","inElastic","sin","outElastic","inOutElastic","inSin","PI","outSin","inOutSin","inExpo","pow","outExpo","inOutExpo","scaledTime","scaledTime1","inBack","magnitude","m","outBack","inOutBack","scaledTime2","noop","Date","Tween","context","_c","ease","onUpdate","onComplete","delay","duration","paused","_proto","prototype","startTime","step","from","to","easeFn","elapsed","frame","progress","min","value","values","val","index","Number","isNaN","addValues","array","self","onStart","shouldSetState","onSetState","frameTotal","ceil","stateToTween","entries","entry","getStateToTween","startValuesArr","endValuesArr","vals","tweenedState","reduce","reducer","obj","shift","_evs","splice","indexOf","strings","funcs","str","match","join","trim","hasOwnProperty","htmel","out","elems","children","q","attr","addEventListener","store","localStorage","syncTabs","syncTab","event","newValue","sounds","isArr","AudioContext","webkitAudioContext","audioCtx","createGain","createGainNode","createDelay","createDelayNode","library","src","filters","filterList","totalFiles","loadedFiles","fileLoaded","buffer","item","cloneBuffer","addToLibrary","cb","audioObj","settings","checkAllFilesLoaded","autoplay","play","dispatchEvent","CustomEvent","detail","inBuffer","outBuffer","createBuffer","numberOfChannels","sampleRate","od","getChannelData","set","playFrom","fadeIn","fadeOut","rapidFire","mute","unmute","connectTo","onPlay","onPause","onResume","onStop","onChange","input","createBufferSource","output","destination","audioNodes","isPlaying","volume","muted","playbackRate","startOffset","isDisabled","createNodes","connectNodes","currentTime","randomiseSound","setupNodesFor","soundObj","randomization","r","getAudioNode","setNodeProps","graph","filterNodes","allFilters","gain","type","createFilterNode","prop","createStereoPanner","createPanner","createBiquadFilter","eqNode","createConvolver","createAnalyser","createDynamicsCompressor","ct","has","setVal","setValueAtTime","z","abs","setPosition","panValue","frequency","freq","Q","decay","reverse","reverb","impulse","left","right","multi","impulseResponse","fftSize","minDecibels","maxDecibels","smoothingTimeConstant","visualiser","threshold","knee","ratio","attack","release","noteOn","attachedSounds","snd","curr","connect","count","dly","loopSetting","time","prevVol","otherSound","filter","durationInSeconds","endVol","fade","endValue","gn","exponentialRampToValueAtTime","hasFilters","url","req","XMLHttpRequest","open","responseType","onload","response","decodeAudioData","onprogress","percent","lengthComputable","loaded","total","send","loadFile","audio","body","getBoundingClientRect","offset","guideline","documentElement","clientHeight","totalFrames","bounds","outside","top","bottom","height","direction","prevPos","scrollProps","toFixed","ready","definition","buckets","WeakMap","tngStack","useHooks","fns","tngf","reset","bucket","getCurrentBucket","cleanup","cleanups","pop","stateSlots","effects","memoizations","nextStateSlotIdx","nextEffectIdx","nextMemoizationIdx","args","effect","guards","runEffects","useState","useReducer","useEffect","effectIdx","guardsChanged","ret","useMemo","useCallback","inputGuards","useRef","initialValue","ref","current","useDeferred","deferred","resolve","reject","pr","Promise","res","rej","useThrottle","timer","TypeError","slot","lastExecute","throttledFn","get","initialVal","prevVal","vOrFn","reducerFn","initialReduction","guards1","guards2","guard","is","memoization","assign"],"mappings":"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"}