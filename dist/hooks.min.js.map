{"version":3,"file":"hooks.min.js","sources":["../src/hooks.js"],"sourcesContent":["// Taken from: \n// https://github.com/getify/TNG-Hooks/blob/master/src/tng-hooks.src.js\n\n// Changes: \n// 1. main function renamed to useHooks()\n// 2. added useDeferred and useThrottle from forks\n\n(function UMD(context,definition){\n  /* istanbul ignore next */if (typeof define === \"function\" && define.amd) { define(definition); }\n  /* istanbul ignore next */else if (typeof module !== \"undefined\" && module.exports) { module.exports = definition(); }\n  /* istanbul ignore next */else { Object.assign(context,definition()); }\n})(this,function DEF(){\n  \"use strict\";\n\n  var buckets = new WeakMap();\n  var tngStack = [];\n\n  return {\n    useHooks, useState, useReducer, useEffect,\n    useMemo, useCallback, useRef, useDeferred,\n    useThrottle\n  };\n\n\n  // ******************\n\n  function useHooks(...fns) {\n    fns = fns.map(function mapper(fn){\n      tngf.reset = reset;\n      return tngf;\n\n\n      // ******************\n\n      function tngf(...args) {\n        tngStack.push(tngf);\n        var bucket = getCurrentBucket();\n        bucket.nextStateSlotIdx = 0;\n        bucket.nextEffectIdx = 0;\n        bucket.nextMemoizationIdx = 0;\n\n        try {\n          return fn.apply(this,args);\n        }\n        finally {\n          // run (cleanups and) effects, if any\n          try {\n            runEffects(bucket);\n          }\n          finally {\n            tngStack.pop();\n          }\n        }\n      }\n\n      function runEffects(bucket) {\n        for (let [idx,[effect,guards]] of bucket.effects.entries()) {\n          try {\n            if (typeof effect == \"function\") {\n              effect();\n            }\n          }\n          finally {\n            bucket.effects[idx][0] = undefined;\n          }\n        }\n      }\n\n      function reset() {\n        tngStack.push(tngf);\n        var bucket = getCurrentBucket();\n        try {\n          // run all pending cleanups\n          for (let cleanup of bucket.cleanups) {\n            if (typeof cleanup == \"function\") {\n              cleanup();\n            }\n          }\n        }\n        finally {\n          tngStack.pop();\n          bucket.stateSlots.length = 0;\n          bucket.effects.length = 0;\n          bucket.cleanups.length = 0;\n          bucket.memoizations.length = 0;\n          bucket.nextStateSlotIdx = 0;\n          bucket.nextEffectIdx = 0;\n          bucket.nextMemoizationIdx = 0;\n        }\n      }\n    });\n\n    return (fns.length < 2) ? fns[0] : fns;\n  }\n\n\n  function getCurrentBucket() {\n    if (tngStack.length > 0) {\n      let tngf = tngStack[tngStack.length - 1];\n      let bucket;\n      if (!buckets.has(tngf)) {\n        bucket = {\n          nextStateSlotIdx: 0,\n          nextEffectIdx: 0,\n          nextMemoizationIdx: 0,\n          stateSlots: [],\n          effects: [],\n          cleanups: [],\n          memoizations: [],\n        };\n        buckets.set(tngf,bucket);\n      }\n\n      return buckets.get(tngf);\n    }\n  }\n\n  function useState(initialVal) {\n    var bucket = getCurrentBucket();\n    // console.log('useState:bucket', bucket);\n    if (bucket) {\n      const reducer = function reducer(prevVal,vOrFn) {\n        // console.log('useState:reducer', prevVal,vOrFn);\n        return typeof vOrFn == \"function\" ?\n          vOrFn(prevVal) :\n          vOrFn;\n      };\n      return useReducer(reducer,initialVal);\n    }\n    else {\n      throw new Error(\"useState() only valid inside an Articulated Function or a Custom Hook.\");\n    }\n  }\n\n  function useThrottle(fn, timer, ...guards) {\n    if(!fn) { throw new TypeError('useThrottle() requires a function argument')}\n    if(!timer) { throw new TypeError('useThrottle() requires a timer argument')}\n\n    var bucket = getCurrentBucket();\n    if (bucket) {\n      const [slot] = useState({fn, timer, lastExecute: 0});\n\n      if (guards.length > 0) {\n        if (guards.length === 1 && Array.isArray(guards[0])) {\n          guards = guards[0];\n        }\n      }\n\n      if (!slot.throttledFn || guardsChanged(slot.guards, guards)) {\n        slot.guards = guards;\n        slot.timer = timer;\n        slot.fn = fn;\n        slot.throttledFn =  function throttledFunction(...args) {\n          const {fn, timer, lastExecute} = slot;\n          const currentTime = Date.now();\n\n          if(lastExecute + timer < currentTime) {\n            try {\n              fn.apply(this, args);\n            } finally {\n              slot.lastExecute = currentTime;\n            }\n          }\n        };\n      }\n\n      return slot.throttledFn;\n\n    }\n    else {\n      throw new Error(\"useThrottle() only valid inside an Articulated Function or a Custom Hook.\");\n    }\n  }\n\n  function useReducer(reducerFn,initialVal,...initialReduction) {\n    var bucket = getCurrentBucket();\n    if (bucket) {\n      // need to create this state-slot for this bucket?\n      if (!(bucket.nextStateSlotIdx in bucket.stateSlots)) {\n        let slot = [\n          typeof initialVal == \"function\" ? initialVal() : initialVal,\n          function updateSlot(v){\n            slot[0] = reducerFn(slot[0],v);\n          },\n        ];\n        bucket.stateSlots[bucket.nextStateSlotIdx] = slot;\n\n        // run the reducer initially?\n        if (initialReduction.length > 0) {\n          bucket.stateSlots[bucket.nextStateSlotIdx][1](initialReduction[0]);\n        }\n      }\n\n      return [...bucket.stateSlots[bucket.nextStateSlotIdx++]];\n    }\n    else {\n      throw new Error(\"useReducer() only valid inside an Articulated Function or a Custom Hook.\");\n    }\n  }\n\n  // NOTE: both `guards1` and `guards2` are either\n  //    `undefined` or an array\n  function guardsChanged(guards1,guards2) {\n    // either guards list not set?\n    if (guards1 === undefined || guards2 === undefined) {\n      // force assumption of change in guards\n      return true;\n    }\n\n    // guards lists of different length?\n    if (guards1.length !== guards2.length) {\n      // guards changed\n      return true;\n    }\n\n    // check guards lists for differences\n    //    (only shallow value comparisons)\n    for (let [idx,guard] of guards1.entries()) {\n      if (!Object.is(guard,guards2[idx])) {\n        // guards changed\n        return true;\n      }\n    }\n\n    // assume no change in guards\n    return false;\n  }\n\n  function useEffect(fn,...guards) {\n    // passed in any guards?\n    if (guards.length > 0) {\n      // only passed a single guards list?\n      if (guards.length == 1 && Array.isArray(guards[0])) {\n        guards = guards[0];\n      }\n    }\n    // no guards passed\n    // NOTE: different handling than an empty guards list like []\n    else {\n      guards = undefined;\n    }\n\n    var bucket = getCurrentBucket();\n    if (bucket) {\n      // need to create this effect-slot for this bucket?\n      if (!(bucket.nextEffectIdx in bucket.effects)) {\n        bucket.effects[bucket.nextEffectIdx] = [];\n      }\n\n      let effectIdx = bucket.nextEffectIdx;\n      let effect = bucket.effects[effectIdx];\n\n      // check guards?\n      if (guardsChanged(effect[1],guards)) {\n        // define effect handler\n        effect[0] = function effect(){\n          // run a previous cleanup first?\n          if (typeof bucket.cleanups[effectIdx] == \"function\") {\n            try {\n              bucket.cleanups[effectIdx]();\n            }\n            finally {\n              bucket.cleanups[effectIdx] = undefined;\n            }\n          }\n\n          // invoke the effect itself\n          var ret = fn();\n\n          // cleanup function returned, to be saved?\n          if (typeof ret == \"function\") {\n            bucket.cleanups[effectIdx] = ret;\n          }\n        };\n        effect[1] = guards;\n      }\n\n      bucket.nextEffectIdx++;\n    }\n    else {\n      throw new Error(\"useEffect() only valid inside an Articulated Function or a Custom Hook.\");\n    }\n  }\n\n  function useMemo(fn,...inputGuards) {\n    // passed in any input-guards?\n    if (inputGuards.length > 0) {\n      // only passed a single inputGuards list?\n      if (inputGuards.length == 1 && Array.isArray(inputGuards[0])) {\n        inputGuards = inputGuards[0];\n      }\n    }\n    // no input-guards passed\n    // NOTE: different handling than an empty inputGuards list like []\n    else {\n      // the function itself is then used as the only input-guard\n      inputGuards = [fn];\n    }\n\n    var bucket = getCurrentBucket();\n    if (bucket) {\n      // need to create this memoization-slot for this bucket?\n      if (!(bucket.nextMemoizationIdx in bucket.memoizations)) {\n        bucket.memoizations[bucket.nextMemoizationIdx] = [];\n      }\n\n      let memoization = bucket.memoizations[bucket.nextMemoizationIdx];\n\n      // check input-guards?\n      if (guardsChanged(memoization[1],inputGuards)) {\n        try {\n          // invoke the to-be-memoized function\n          memoization[0] = fn();\n        }\n        finally {\n          // save the new input-guards\n          memoization[1] = inputGuards;\n        }\n      }\n\n      bucket.nextMemoizationIdx++;\n\n      // return the memoized value\n      return memoization[0];\n    }\n    else {\n      throw new Error(\"useMemo() only valid inside an Articulated Function or a Custom Hook.\");\n    }\n  }\n\n  function useCallback(fn,...inputGuards) {\n    if (getCurrentBucket()) {\n      return useMemo(function callback(){ return fn; },...inputGuards);\n    }\n    else {\n      throw new Error(\"useCallback() only valid inside an Articulated Function or a Custom Hook.\");\n    }\n  }\n\n  function useRef(initialValue) {\n    if (getCurrentBucket()) {\n      // create a new {} object with a `current` property,\n      // save it in a state slot\n      var [ref] = useState({ current: initialValue, });\n      return ref;\n    }\n    else {\n      throw new Error(\"useRef() only valid inside an Articulated Function or a Custom Hook.\");\n    }\n  }\n\n  function useDeferred() {\n    if (getCurrentBucket()) {\n      const [deferred] = useState((function () {\n        let resolve, reject;\n        let pr = new Promise((res, rej) => {\n          resolve = res;\n          reject = rej;\n        })\n\n        return { pr, resolve, reject }\n      })())\n\n      return deferred\n    } else {\n      throw new Error(\"useDeferred() only valid inside an Articulated Function or a Custom Hook.\")\n    }\n  }\n\n});\n"],"names":["context","definition","this","buckets","WeakMap","tngStack","useHooks","fns","map","fn","tngf","reset","push","bucket","getCurrentBucket","cleanup","cleanups","pop","stateSlots","length","effects","memoizations","nextStateSlotIdx","nextEffectIdx","nextMemoizationIdx","args","apply","idx","effect","guards","entries","undefined","runEffects","useState","useReducer","useEffect","Array","isArray","Error","effectIdx","guardsChanged","ret","useMemo","useCallback","inputGuards","useRef","initialValue","ref","current","useDeferred","deferred","resolve","reject","pr","Promise","res","rej","useThrottle","timer","TypeError","slot","lastExecute","throttledFn","currentTime","Date","now","has","set","get","initialVal","prevVal","vOrFn","reducerFn","initialReduction","v","guards1","guards2","guard","Object","is","memoization","module","exports","assign"],"mappings":"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"}